---
marp: true
paginate: true
---

# 커넥션 관리의 종류와 등장

---

## HTTP 통신

- TCP/IP(이하 TCP)를 통해 데이터를 전송한다.
- 왜냐하면 데이터 전송에 신뢰를 할 수 있기 때문이다.

---

## 신뢰할 수 있는 TCP 데이터 전송

- TCP를 이용한 데이터 전송에 신뢰가 되는 이유
  - HTTP 요청을 보내기 전에 연결이 되었는지 확인 작업을 한다.
  - [TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크](https://evan-moon.github.io/2019/11/17/tcp-handshake/)

---

## 연결 확인 작업의 대표적인 단점

- 단점
  - TCP 커넥션 지연(데이터 전송)을 늦게 한다. (slow-start)
  - 전송 대기 시간 증가

---

## 커넥션 관리

- 트렌잭션 = (확인작업 + 커넥션 시작) + (요청 + 응답) + 커넥션 종료
- 매 트렌잭션 마다 확인 작업 횟수를 줄일 수 없을까?
- 매 커넥션을 효율적으로 활용할 수 없을까?
- 방법론
  - 병렬 커넥션
  - 지속 커넥션
  - 파이프라인 커넥션
  - 다중 커넥션

---

## 병렬 커넥션

- 여러 요청을 여러 커넥션으로 통신한다.
  - 즉, 각 트렌잭션이 `병렬`로 처리된다.
- 예를 들어, 티켓팅이 한줄인지 여러줄인지로 생각해볼 수 있다.
- 장점
  - 전체 소요 시간을 줄일 수 있다.
- 단점
  - 각 트렌잭션마다 확인 작업하는 것은 동일함.
  - 하나의 클라이언트로부터 다수의 커넥션으로 처리하므로 성능상 이슈 발생
  - 네트워크 대폭역이 좁으면 무의미

---

## 지속 커넥션

- 하나의 트렌잭션 후 커넥션을 종료하지 않고, 계속 연결된 상태로 두는 것
- 트렌잭션마다 확인 작업을 하지 않음 => `TCP 커넥션 지연` 감소
- `HTTP 1.0+` 의 `keep-alive`
  - 중간에 프락시가 개입하면 혼란스러워짐
  - 이를 해결하고자 설계를 개선하여 HTTP 1.1 지속 커넥션이 등장
- `HTTP 1.1` 의 `지속 커넥션`
  - 기본값으로 매 커넥션이 지속 커넥션으로 취급한다.

---

## 파이프라인 커넥션

- HTTP 1.1 의 지속 커넥션을 통해서 요청을 파이프라이닝
- 응답을 받기 전에 다음 요청을 하는 것 => `전송 대기 시간` 단축

---

## 다중 커넥션

- HTTP 2의 커넥션 관리 방법
  - 파이프라인 커넥션의 단점인 요청과 응답의 순서가 같음을 개선
  - [HTTP 버전 비교](https://dl.ifip.org/db/conf/cnsm/cnsm2016/1570287809.pdf)

---

### 관련 단원
- 4장 커넥션 관리

### 참고 링크

- [TCP가 연결을 생성하고 종료하는 방법, 핸드쉐이크](https://evan-moon.github.io/2019/11/17/tcp-handshake/)
- [HTTP 버전 비교](https://dl.ifip.org/db/conf/cnsm/cnsm2016/1570287809.pdf)
