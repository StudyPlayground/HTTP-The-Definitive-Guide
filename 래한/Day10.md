# 16. 국제화

웹을 이용하는 사용자들의 언어는 다양하므로 HTTP는 여러 언어와 문자로 된 국제 문서들의 처리 및 전송을 지원해야 한다. 이번 장에서 다를 내용은 다음과 같다.

- HTTP가 어떻게 여러 언어 문자들의 체계 및 표준과 상호작용하는지 설명한다.
- HTTP 프로그래머가 올바르게 업무를 수행하는데 도움이 될 수 있도록 전문용어, 기술, 표준의 간략한 개요를 제공한다.
- 언어를 위한 표준 명명 체계와, 어떻게 표준화된 언어 태그가 선택한 콘텐츠를 서술하는지에 대해 설명한다.
- 국제화된 URI의 규칙과 주의사항을 개괄적으로 서술한다.
- 날짜와 그 외 다른 국제화 이슈에 대해 간단히 논의한다.

# 16.1. 국제적인 콘텐츠를 다루기

HTTP에서 엔터티 본문은 비트들로 가득 찬 상자에 불과 하다. 국제 콘텐츠를 지원하기 위해 서버는 클라이언트에게 각 문서의 문자와 언어를 Content-Type charset과 Content-Language 헤더를 통해 알려준다. 서버는 국제화를 위해 다양한 언어의 문서를 준비할수 있다. 클라이언트는 요청을 보낼 때 어떤 언어의 문서를 원하는지 다음 방식으로 알릴 수 있다.

```bash
Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8
```

# 16.2. 문자집합과 HTTP

## 16.2.1. 차셋(Charset)은 글자를 비트로 변환하는 인코딩이다.

HTTP 차셋 값은, 수신자에게 엔터티 콘텐츠 비트들을, 어떻게 특정 문자 체계의 글자들로 바꿔야 하는지 말해준다.

charset의 예로는 us-ascii, utf-8, euc-kr, ios-8859 등이 있다.

```tsx
HTTP/1.1 200 OK
Content-Type: text/html; charset=iso-8859-6
Content-length: 18572
Content-language: ar
```

## 16.2.2. 문자집합과 인코딩은 어떻게 동작하는가

인코딩을 두 단계에 걸쳐 일어난다. bits → character code → unique character.

![스크린샷 2023-07-24 오후 9.52.14.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c111fd8-d2a1-46b3-abbb-cb46da905d26/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.52.14.png)

데이터 비트인 11100001은 iso-8859-6의 인코딩을 사용하여 225라는 값으로 변환되고, iso-8859-6 문자 집합에서 225번에 해당되는 ARABIC LETTER FEH라는 문자를 찾는다. 그리고 이 유일한 문자로 화면에 보여줄 글자 모양을 찾는다.

## 16.2.3. 잘못된 차셋은 잘못된 글자들을 낳는다.

같은 225(11100001)을 사용하더라도 character code가 다른 문자체계에서는 다르게 보일수 있다.

- iso-8859-1

  ![스크린샷 2023-07-24 오후 10.21.00.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0dde31fd-6c60-423b-aa05-e46475d74cbe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.21.00.png)

- iso-8859-6

  ![스크린샷 2023-07-24 오후 10.21.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/143e2e60-65a2-4da5-958a-9f0194f01388/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.21.25.png)

- iso-8859-7

  ![스크린샷 2023-07-24 오후 10.21.34.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03d0d29c-401c-4d86-a7b2-cea553a2a70a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.21.34.png)

- iso-8859-8

  ![스크린샷 2023-07-24 오후 10.21.43.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8cf18dbc-1676-49e5-9a79-f7fdb1899d98/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.21.43.png)


## 16.2.4. 표준화된 MIME 차셋 값

특정 문자 인코딩과 특정 코딩된 문자집합의 결합을 MIME 차셋이라 부른다. HTTP는 표준화된 MIME 차셋 태그를 Content-Type과 Accept-Charset 헤더에 사용한다.

[Language Code Table](http://www.lingoes.net/en/translator/langcode.htm)

## **16.2.5 Content-Type charset 헤더와 META 태그**

HTTP 메시지에 아래 처럼 MIME 차셋 태그를 헤더에 담아 보냄으로 해당 문서의 형식과 문자 인코딩을 클라이언트에 알려준다.

```tsx
Content-Type: text/html; charset=iso-8859-6
```

그리고 HTML 문서 내의 <meta> 태그에서도 지정할 수 있다. 다만 HTTP 헤더의 charset이 더 우선적으로 적용된다.

# 16.3. 다중언어 문자 인코딩에 대한 지침

## 16.3.1. 문자집합 용어

문자 - 알파벳, 숫자, 구두점, 기호 등 글쓰기의 최소 단위. Unicode라 불리는 국제 문자 세트 계획에 따라 여러 글자에게 알맞고 유일한 이름을 부여하기 위한 표준화된 이름 집합이 있다.

코딩된 문자(coded character) - 글자에 할당된 유일한 숫자, ASCII에서 A는 65, a는 97이다.

코드 공간

코드 너비 - 문자 코드의 고정된 크기의 비트 개수

사용 가능 문자집합

코딩된 문자집합

문자 인코딩 구조

## 16.3.2. 차셋(Charset)은 형편없는 이름이다

charset보단 character encoding이라는 표현이 더 맞다.

charset은 원래 Character set의 약어로 문자 집합을 의미하고, 처음에는 올바른 용어였다.

- gpt

  "Charset"은 원래는 "Character Set"의 약어로 문자 집합을 의미합니다. 따라서 처음에는 올바른 용어였습니다. 그러나 현대적인 컴퓨터 시스템과 웹 기술의 발전으로 인해 이 용어가 부적절하다고 여겨지는 이유가 있습니다.

    1. 문자 집합과 문자 인코딩의 구분: "Charset"은 문자 집합과 문자 인코딩을 혼용하는 경향이 있습니다. 문자 집합(Character Set)은 문자의 집합을 정의하는 것으로, 예를 들어 ASCII, UTF-8, UTF-16, ISO-8859-1 등이 문자 집합에 해당합니다. 반면에 문자 인코딩(Character Encoding)은 문자를 컴퓨터에서 저장하고 전송하기 위해 숫자 코드로 변환하는 방식을 의미합니다. 문자 인코딩은 문자 집합을 컴퓨터에서 이해할 수 있는 이진 데이터로 변환하는 방법입니다. "Charset"이라는 용어는 이러한 구분을 명확히 하지 않으므로 혼란을 줄 수 있습니다.
    2. 문자 인코딩의 중요성: 문자 인코딩은 문자 집합을 컴퓨터에서 사용 가능한 이진 데이터로 변환하는 과정이므로 매우 중요합니다. 데이터를 올바른 문자 인코딩 방식으로 해석하지 않으면 문자가 깨지거나 오류가 발생할 수 있습니다. 따라서 문자 집합과 문자 인코딩을 함께 명시하는 것이 더 명확하고 정확합니다.
    3. 유니코드의 등장: ASCII와 같은 초기 문자 집합은 영어 알파벳과 몇 가지 특수 문자를 지원하지만, 다양한 언어와 문자를 지원하기에는 부족했습니다. 이로 인해 유니코드가 등장하게 되었습니다. 유니코드는 전 세계의 거의 모든 문자를 포함하는 문자 집합으로, 다양한 문자 인코딩 방식을 제공합니다. 따라서 "Charset"이라는 용어는 이제 더 이상 모든 문자를 표현하는 데에는 부적절한 용어로 여겨지는 것입니다.

  따라서 현대적인 웹 개발에서는 "charset" 대신 "character encoding"이라는 용어를 사용하여 문자 집합과 문자 인코딩을 명확하게 구분하고 사용하는 것이 바람직합니다.


## 16.3.3. 문자

하나의 문자가 용도(수학기호, 구두점)에 따라 다르게 표현된다.

![스크린샷 2023-07-24 오후 10.45.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6734cdef-6f0e-409b-8b45-1c5e0d22f9e4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.45.17.png)

같은 글자가 위치에 따라 다르게 표기되기도 한다.

![스크린샷 2023-07-24 오후 10.45.45.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/335283dd-1172-4225-a66c-4f0502dbceea/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.45.45.png)

## 16.3.4. 글리프(glyphs), 연자(ligatures) 그리고 표현 형태

f와 i가 만날 때 i의 점이 사라지도록 표현하는데 fi 연자가 존재하면 사라지도록 표현하고 아니면 그냥 표현한다.

![스크린샷 2023-07-24 오후 10.47.24.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/24a78a46-a9b4-43e5-b29a-08944659b6fb/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.47.24.png)

## 16.3.5. 코딩된 문자집합(Coded Character Set)

글자에 할당된 유일한 숫자, ASCII에서 A는 65, a는 97이다.

ascii라 불리는 us-ascii, iso-8859 시리즈(iso-8859-1, iso-8859-2...)는 중요하다.

UTF-8또한 중요하다.

## 16.3.6. 문자 인코딩 구조

고정폭, 가변폭으로 나눠지고 가변폭은 모달형과 비모달형으로 한번 더 나뉜다.

iso-8859 시리즈는 8비트 고정폭을 사용한다.

고정폭은 고정된 길이의 비트로 문자를 표현해 빠르게 처리될수 있지만 공간을 낭비할수 있다.

가변폭 비모달형은 다른 문자 코드 번호에 다른 길이의 비트를 사용한다. 자주 사용하는 글자의 비트 길이를 줄일 수 있고, 국제 문자에 대해서는 여러 바이트를 사용함으로 이전 8비트 문자집합과의 호환성도 유지 가능하다. UTF-8이 대표적이다.

가변폭 모달형은 다른 모드로의 전환을 위해 특별한 escape 패턴을 사용한다.

![문자 인코딩 구조는 character code를 비트들로 인코딩하고 다시 원래대로 돌려놓는다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c04597bf-61a1-47ed-831d-7ae4f99fc2c3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.53.46.png)

문자 인코딩 구조는 character code를 비트들로 인코딩하고 다시 원래대로 돌려놓는다.

UTF-8은 전세계의 문자를 표현하는 가장 대표적인 문자 집합으로 비모달 가변길이 인코딩 방식이다. 최대 6바이트를 사용한다.

57 → 00111001

245 → 11110101 → 11000011 10110101

536 → 1001111010001 → 11100001 10001111 10010001

**Unicode와 UTF-8**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81ac289a-e4d4-49d1-80dd-6ad378f25ad2/Untitled.png)

U+AC00 → 10101100 00000000 utf-8→ 11101010 10110000 10000000

**EUC-KR(Extended Unix Code-KR)**

KS X 1003: 0-127의 ascii 에 \만 원화로 바꾼 것 KS X 1001: 가 → b0a1, 갓 → b0ab

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5d92aa17-fd7f-422e-8f99-1da11a9abd5a/Untitled.png)

갷은 어떻게 표현할까?

한글 채움 문자(fill code: 0xA4 OxD4)를 사용

(0xA4 OxD4) ㅈ ㅣ ㅂ → 집

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f85fea57-138e-4625-818a-8bb3aafd572c/Untitled.png)

http://i18nl10n.com/korean/euckr.html

# 16.4. 언어 태그와 HTTP

언어 태그는 언어에 이름을 붙이기 위한 짧고 표준화된 문자열이다.

한국의 ko-KR, 미국의 en-US, 브라질 포르투갈어(pt-BR)

## 16.4.1. Content-Language 헤더

엔터티가 어떤 언어 사용자를 대상으로 하고 있는지 서술한다. 프랑스어 사용자를 대상으로 한다면 Content-Language: fr 이라 표현한다. 언어뿐 아니라 오디오, 동영상을 위한 값도 있다.

## 16.4.2. Accept-Language 헤더

특정 언어로 된 콘텐츠를 요청하려면 클라이언트에서 이 값을 넣어서 보내야한다.

## 16.4.3. 언어 태그의 종류

언어태그는 RFC 3066 으로 문서화된 표준화된 문법을 갖고 있다.

[링크 참조](http://www.lingoes.net/en/translator/langcode.htm)

## 16.4.4. 서브태그

언어 태그는 하이픈으로 분리된 하나 이상의 서브태그로 이뤄져 있다.

## 16.4.5. 대소문자의 구분 및 표현

언어는 소문자, 국가는 대분자

## 16.4.6. IANA 언어 태그 등록

## 16.4.7. 첫 번째 서브태그: 이름 공간

언어를 나타내는 첫 번째 서브태그는 ISO 639 표준을 따르는 것이 알번적이다.

![스크린샷 2023-07-24 오후 11.08.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c68e6699-dd17-4c59-aa9e-26f6b1c59042/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.08.47.png)

![스크린샷 2023-07-24 오후 11.09.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fe1e694b-2d2f-41ea-94e2-90888fe2cf13/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.09.06.png)

## 16.4.8. 두 번째 서브 태그: 이름공간

두 번째 서브태그는 ISO 3166에 있는 국가 코드와 지역 표준 집합을 따른다.

![스크린샷 2023-07-24 오후 11.10.09.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3f6fba3b-d0fb-46f8-b52a-1e0bf9642963/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.10.09.png)

![스크린샷 2023-07-24 오후 11.10.24.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/03e8215d-0c26-4a6f-9c96-f8be096ccde2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-07-24_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.10.24.png)

## 16.4.9 나머지 서브태그: 이름공간

영어나 숫자인 것 외 별도의 규칙이 없다.

## 16.4.10 선호 언어 설정하기

웹브라우저 프로필을 통해 선호 언어를 설정할 수 있다.

## 16.4.11 언어 태그 참조표

# 16.5. 국제화된 URI

URI는 국제화를 그다지 지원하지 않는다.

# 17. 내용 협상과 트랜스코딩

어떻게 한 URL을 통해 사용자에 맞는 언어로 콘텐츠를 제공할수 있을까??

HTTP는 클라이언트와 서버가 이런 판단을 할 수 있도록 내용 협상 방법을 제공한다. 이 방법을 이용해 한 URL 여러 가지 리소스 중 적합한 것에 대응되도록 할 수 있다.

콘텐츠를 각기 다른 언어로 표현한 서로 다른 버전을 배리언트(variant)라 한다.

하나의 URL에서 어떤 배리언트를 사용자에게 제공할지 정하는 것이 내용 협상이다.

# 17.1. 내용 협상 기법

내용 협상 기법에는 3가지가 존재하는데 클라이언트 주도 기법, 서버 주도 기법, 투명 기법이 있다.

# 17.2. 클라이언트 주도 협상

클라이언트가 언어를 선택할 페이지를 제공한다.

장점은 구현이 쉽고 명확하게 선택할 수 있다. 단점은 의도한 콘텐츠를 접근하는 데 최소 두 번의 요청이 필요하다.

# 17.3. 서버 주도 협상

클라이언트가 서버에게 선호하는 언어의 정보를 헤더를 통해 전달한다.

- 내용 협상 헤더 (Accept 관련 헤더)
- User-Agent

## 17.3.1. 내용 협상 헤더

클라이언트는 다음 HTTP 헤더를 이용해 선호 정보를 보낼 수 있다.

Accept - 서버가 어떤 미디어 타입으로 보내도 되는지 알려준다.

Accept-Language - 서버가 어떤 언어로 보내도 되는지 알려준다.

Accept-Charset - 서버가 어떤 차셋으로 보내도 되는지 알려준다.

Accept-Encoding - 서버가 어떤 인코딩으로 보내도 되는지 알려준다.

15장의 인터티 헤더들과 비슷한데, 이것은 선적 화물에 붙이는 라벨과 비슷하다. 선호 정보를 교화하고 여러 버전 중 하나를 선택하는 것을 도와 가장 잘 맞는 문서를 제공해 주기 위한 목적으로 사용된다.

서버는 클라이언트의 Aceept 관련 헤더들을 적절한 엔터티 헤더들과 짝을 지어준다.

Accept - Content-Type

Accept-Language - Content-Language

Accept-Charset - Content-Type

Accept-Encoding - Content-Encoding

## 17.3.2. 내용 협상 헤더의 품질 값

클라이언트가 선택 가능한 항목을 선호도와 함께 나열할 수 있도록 품질값을 정의할수 있다.

```bash
Accept: [ text/html, application/json, image/*, ... ]
Accept-Language: fr-CH, fr;q=0.9, en;q=0.8 de;q=0.7, *;q=0.5
Accept-Charset: utf-8, iso-8859-1;q=0.5, *;q=0.1
Accept-Encoding: br;q=1.0, gzip;q=0.8, *;q=0.1
```

## 17.3.3. 그 외의 헤더들에 의해 결정

User-Agent를 보고 오래된 환경의 브라우저라면 별도의 처리가 필요할 수 있다.

## 17.3.4. 아파치의 내용 협상

아래의 type-map 파일을 통해 적절한 문서를 내려준다.

```tsx

URI: test.html

URI: test.en.html
Content-Type: text/html
Content-Language: en

URI: test.ko.html
Content-Type: text/html; charset=utf-8
Content-Language: ko, en
```

## 17.3.5. 서버 측 확장

서버에서 내용 협상을 구현하는 또 다른 방법이다.

# 17.4. 투명 협상

클라이언트 협상과 서버 협상 방식을 함께 사용하여 클라이언트와 서버가 상호적으로 최적을 결정을 내리는 것을 의미한다. Accept, Accept-Encoding과 같은 헤더가 사용될 수 있다.

서버 주도 협상을 좀 더 확장하면, 서버 측에서 내용 협상 헤더를 통해 특정 배리언트를 응답으로 내려주었을 것이다. 그런데 캐시 서버 입장에서는 특정 URL에 응답만 기억할 것인데, 이 때 다른 내용 협상 헤더를 가지고 같은 URL로 요청을 하면 캐시 서버는 엉둥한 언어의 응답을 내려줄 수 있다.

HTTP/1.1 명세에 투명 협상에 대한 메커니즘을 정의하지 않았지만, 캐시에 관한 Vary 헤더를 정의했다. 서버에서 User-Agent와 Accept-Language를 참조하여 응답을 내려줬다면, 응답에 다음처럼 Vary 헤더에 추가하는 것이다.

```tsx
Vary: User-Agent, Accept-Language
```

그러면 다음에 같은 URL로 요청이 왔을 때 User-Agent와 Accept-Language가 일치할 때만 캐시된 응답을 내려준다.

# 17.5. 트랜스코딩

클라이언트와 서버가 협상을 통해 어떤 URL이 가리키는 리소스 중 요청에 가장 잘 맞는 것을 응답하는 메커니즘에 대해 살펴 봤다. 이때 요구에 맞는 리소스가 아예 없다면 어떻게 될까?? 에러를 응답해야 겠지만 이론적으로 서버는 기존 문서를 클라이언트가 사용할 수 있는 무언가로 변환할 수도 있다. 이 옵션을 트랜스코딩이라 부른다.

HTML → WML

고해상도 이미지 → 저해상도 이미지

64K색 이미지 → 흑백 이미지

프레임이 복잡한 페이지 → 단순히 텍스트만 가진 페이지

광고가 있는 페이지 → 광고가 없는 페이지