# 5. 웹서버

# 5.1. 다채로운 웹 서버

웹 서버는 HTTP 요청을 처리하고 응답을 처리하는 하드웨어 장비나 소프트웨어로 매우 다양하다.

## 5.1.1. 웹 서버 구현

웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능(설정, 통제, 확장)을 제공한다.

## 5.1.2. 다목적 소프트웨어 웹 서버

nginx, apache, ms, google등 많은 웹서버가 있다. 최근에는 nginx를 가장 많이 사용한다.

![스크린샷 2023-05-09 16.27.27.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abf0ccf6-4997-46b0-8d83-69238b29d2ae/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_16.27.27.png)

## 5.1.3. 임베디드 웹 서버

소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버이다.

# 5.2. 간단한 펄 웹 서버

요지는 완전한 기능을 갖춘 HTTP 서버를 만들려면 해야 할 일이 많지만, 최소한의 기능을 가진 HTTP서버를 아주 짧은 Perl 코드로 만들수 있단 뜻이다. 사실 Node.js가 더 짧다.

# 5.3. 진짜 웹 서버가 하는 일

![스크린샷 2023-05-09 16.32.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1f7935e2-c8a9-4090-be1d-928c2494067e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_16.32.42.png)

1. 커넥션을 맺는다. — 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
2. 요청을 받는다. — 요청 메시지를 해석하고 행동을 취한다.
3. 요청을 처리한다. — 요청 메시지를 해석하고 행동을 취한다.
4. 리소스에 접근한다. — 메시지에서 지정한 리소스에 접근한다.
5. 응답을 만든다. — 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. 응답을 보낸다. — 응답을 클라이언트에게 돌려준다.
7. 트랜잭션을 로그로 남긴다. — 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

# 5.4. 단계 1: 클라이언트 커넥션 수락

클라이언트가 이미 서버에 대해 열려있는 지속적 커넥션을 갖고 있다면, 있는 것을 사용하고 없다면 새 커넥션을 생성해야 한다.

## 5.4.1. 새 커넥션 다루기

서버는 연결된 클라이언트의 IP 정보를 기반으로 커넥션을 생성한다. IP 주소를 검증하여 필요에 따라 커넥션을 닫을 수 있다.

## 5.4.2. 클라이언트 호스트 명 식별

역방향 DNS를 통해 IP로 부터 호스트명을 얻고 호스트명을 분석한다.

일반적으로 DNS 조회는 포워드로 이뤄지지만 리버스(역방향) DNS는 IP주소로 도메인 네임을 얻는다.

## 5.4.3. ident를 통해 클라이언트 사용자 알아내기

서버에서 ident 값을 확인하는 별도의 절차가 있다. 113번 포트를 사용한다. 하지만 많은 소프트웨어가 지원하지 않아서 잘 사용되지 않는다.

# 5.5. 단계 2: 요청 메시지 수신

서버는 요청 메시지를 파싱한다.

- 요청줄(요청 메시지의 시작줄)을 파싱하여 요청 메서드, 리소스(URL), 버전 정보를 찾는다. 각 값은 스페이스 한 개로 분리돼 있고 끝에는 CRLF로 끝난다.
- 메시지 헤더를 읽는다. 각 헤더는 CRLF로 끝난다.
- 헤더의 끝을 의미하는 CRLF로 끝나는 빈줄(개행)을 찾고 존재한다면 아래 본문을 읽는다.
- 파싱을 끝낸다.

## 5.5.1. 메시지의 내부 표현

메시지를 내부의 자료구조로 파싱해 가지고 있는다.

![스크린샷 2023-05-09 17.10.05.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4e6d538-976d-464f-a38e-53a3c5d86f58/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_17.10.05.png)

## 5.5.2. 커넥션 입력/출력 처리 아키텍처

고성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있다.

![스크린샷 2023-05-09 17.11.06.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3c48f8c6-c338-4b37-9fbb-23a06ffc2773/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_17.11.06.png)

# 5.6. 단계 3: 요청 처리

요청 처리는 뒤에서 다룬다.

# 5.7. 단계 4: 리소스의 매핑과 접근

웹 서버는 리소스 서버로, URI에 접근하면 컨텐츠를 제공해준다.

## 5.7.1. Docroot

웹 서버 파일 시스템의 특별한 폴더를 웹 콘텐츠를 위해 설정한다. 아파치 웹 서버를 기준으로 `/usr/local/httpd/files` 폴더에 해당한다.

만약 https://www.kakao.com/logo.wepb 에 접근한다면 해당 서버의 /usr/local/httpd/files/logo.webp 에 접근하는 식이다.

여기서 서버는 상대적인 url이 docroot 이외 부분이 노출되지 않게 해야한다. 예를들면 https://www.kakako.com/ 처럼 디렉토리의 부모에 접근하는 것을 막아야한다.

또한 docroot를 사용할 때 가상 호스팅 방식으로 하나의 웹 서버에서 여러 루트를 사용할 수 있다.

![스크린샷 2023-05-09 17.29.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae6f4ffd-c949-4268-b11a-248329e3f0b4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_17.29.17.png)

```xml
<VirtualHost www.joes-hardware.com> 
  ServerName www.joes-hardware.com 
  DocumentRoot /docs/joe 
  TransferLog /logs/joe.access_log 
  ErrorLog /logs/joe.error_log 
</VirtualHost> 

<VirtualHost www.marys-antiques.com> 
  ServerName www.marys-antiques.com 
  DocumentRoot /docs/mary 
  TransferLog /logs/mary.access_log 
  ErrorLog /logs/mary.error_log 
</VirtualHost>
```

## 5.7.2. 디렉터리 목록

웹 서버는 디렉터리에 대한 URL을 받으면 해당 디렉터리에 있는 index.html 파일(보통은 웹 페이지의 시작 점)을 환한다.

## 5.7.3. 동적 콘텐츠 리소스 매핑

웹 서버는 디렉토리나 파일의 위치를 매핑할수 있다.

## 5.7.4. 서버사이드 인클루드(Server-Side Includes, SSI)

PHP, JSP, EJS등 어떤 리소스가 서버사이드 인클루드를 포함한다면 클라이언트에게 보내기 전에 처리한다. 간단히 말해서 HTML파일에 특정한 패턴(주로 HTML 주석안에 포함)이 있다면 그 패턴에 있는 파일, 변수, 스크립트를 치환한다.

```tsx
<!-- #include 속성="파일명" -->
```

요즘은.. 다른 더 좋은 방법이 많다.

## 5.7.5. 접근 제어

HTTP 인증과 관련 있고 12장에서 자세히 다룬다. 각각의 리소스에 접근 제어를 할당 가능하다.

# 5.8. 단계 5: 응답 만들기

서버는 요청에 대해 적절한 응답을 만들어 반환한다.

## 5.8.1. 응답 엔터티

응답 본문이 있다면 주로 다음 내용을 포함한다.

- MIME를 서술하는 Content-Type
- 응답 본문 길이인 Content-Length
- 실제 응답 본문 내용

## 5.8.2. 리다이렉션

필요에 따라 어떤 요청 후 클라이언트에게 이동할 위치를 줄 수 있다. Location 응답 헤더는 페이지를 리다이렉션할 URL을 나타낸다.

# 5.9. 단계 6: 응답 보내기

커넥션에 응답을 보낸다. 요청과 마찬가지로 커넥션의 수는 제한적이기 때문에 커넥션을 잘 관리하는 것이 중요하다. 그리고 지속적인 커넥션이면 Content-Length를 올바른 값으로 줘야한다.

# 5.10. 단계 7: 로깅

웹 서버에서 수행한 내용을 기록한다. 21장에서 더 자세히 다룬다.

# 6. 프락시

# 6.1. 웹 중개자

웹 프락시 서버는 클라이언트의 입장에서 트랙잭션을 수행하는 중개인이다. 나 대신 서버에 요청을 하기 때문에 프락시 서버는 웹 클라이언트이면서 웹 서버이기도 하다.

## 6.1.1. 개인 프락시와 공유 프락시

### 공용 프락시

대부분의 프락시로 여러 클라이언트가 사용하는 프락시이다. 캐시 프락시의 경우 공통된 요청에서 이득을 취할수 있기 때문에 사용자가 많을수록 좋다.

### 개인 프락시

흔하지 않지만 하나의 클라이언트가 독점적으로 사용.

## 6.1.2. 프락시 vs 게이트웨이

프락시: 둘 이상의 애플리케이션을 연결하는데 같은 프로토콜을 사용.

게이트웨이: 서로 다른 프토토콜을 사용하는 둘 이상을 연결

![스크린샷 2023-05-09 18.07.23.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/662ad301-3e7e-4ec4-8cb9-1afa084c7abd/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_18.07.23.png)

사실 둘의 차이(경계)는 모호한게 프락시도 다른 버전의 HTTP 연결, SSL 보안 프로토콜, FTP 등 다른 프로토콜로 연결하는 기능도 포함하기 때문이다.

# 6.2. 왜 프락시를 사용하는가?

프락시는 실용적이고 유용한 모든 것을 한다. 보안, 성능, 비용 절감 등이다. 또한 HTTP 트래픽을 감시, 수정할수 있기 때문에 성인 콘텐츠 필터, 접근 제어, 보안 방화벽, 캐시, 트랜스코더(데이터 수정), 익명화 등의 작업을 할수 있다.

캐시의 경우는 예를 들어 AWS 서버에 직접 접근할 경우 비용이 들 수 있는데, 더 적은 비용의 웹 캐시 서버를 두면 비용 절감을 할 수 있다.

트랜스 코더는 이미지를 더 효율적인 포맷으로 처리한다던지 내용을 변경하는 일이다.

익명화는 개인의 정보가 있을 수 있는 IP 주소, From 헤더, Referer 헤더, 쿠키, URI 세션 아이디 등을 제거하여 클라이언트의 정보를 유추할 수 없게 하는 것이다.

# 6.3. 프락시는 어디에 있는가?

## 6.3.1. 프락시 서버 배치(어떻게 프락시가 네트워크에 배치되는가?)

사용하는 방식에 따라 어디든 배치될 수 있다.

### 출구(Egress) 프락시(그림 a)

로컬 네트워크의 출구, 보안이나 컨텐츠 필터링

### 접근(입구) 프락시(b)

캐시 프락시, ISP 접근 지점에 위치

### 대리 프락시(c)

캐시, 웹서버의 이름과 IP를 스스로 사칭(프락시가 요청을 받아 실제로 프락시가 처리하는 것처럼 보임), 리버스 프락시라고도 함.

### 네트워크 교환 프락시(d)

캐시, 트래픽 흐름 감시

![스크린샷 2023-05-09 18.22.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0b21acd2-9cbc-4d1a-9576-dbe9726a40a5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_18.22.29.png)

## 6.3.2. 프락시 계층(어떻게 프락시의 연쇄가 계층을 이루는가?)

서버 쪽으로 갈수록 부모가 된다.

![스크린샷 2023-05-09 18.24.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/16a643cc-826c-40e3-9f20-3e23e669a19c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_18.24.36.png)

위의 계층은 정적인데, 자식 프락시는 자신이 수행할 일을 요청할 부모 프락시를 동적으로 정할 수 있다.

![스크린샷 2023-05-09 18.28.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0f3c429a-5cfc-4a0a-adcd-791cf5853215/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_18.28.47.png)

## 6.3.3. 어떻게 프락시가 트래픽을 처리하는가

- 클라이언트를 수정(a) - 의도적으로 요청을 원 서버가 아닌 프락시로 보낸다.
- 네트워크를 수정(b) - 스위칭, 라우팅 장치에서 처리하는 인터셉트 프락시.
- DNS에서 수정(c) - 대리 프락시에서 자신의 DNS 테이블을 사용한다.
- 웹 서버를 수정 - 웹서버에서 HTTP 리다이렉션을 실행시킨다.

![스크린샷 2023-05-09 18.53.28.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5cfc88e9-9cd2-4a44-a6e9-57e8878ba60b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_18.53.28.png)

# 6.4. 클라이언트 프락시 설정

브라우저에서 파락시를 제공한다.

수동 설정, 브라우저 기본 설정, 프락시 자동 설정(PAC), WPAD 프락시 발견 등의 방법이 있다.

## 6.4.1. 클라이언트 프락시 설정: 수동

브라우저에서 설정에서 프락시 설정.

## 6.4.2. 클라이언트 프락시 설정: PAC 파일

프락시 설정하는 PAC 파일이 존재, 자바스크립트 코드로 프락시 동적으로 선택

## 6.4.3. 클라이언트 프락시 설정: WPAD

웹 프락시 자동발견 프로토콜.

- PAC URI를 찾기 위해 WPAD를 사용한다.
- 주어진 URI에서 PAC 파일을 가져온다.
- 프락시 서버를 알아내기 위해 PAC 파일을 실행한다.
- 알아낸 프락시 서버를 이용해서 요청을 처리한다.

# 6.5. 프락시 요청의 미묘한 특징들

## 6.5.1. 프락시 URI는 서버 URI와 다르다

클라이언트가 요청을 보내면 스킴, 호스트, 포트 번호가 없는 URI(GET /index.html HTTP/2.0)를 보내는데, 프락시에 요청을 할 땐 완전한 URI(https://www.kakao.com/index.html)를 사용한다. 이유는 프락시는 원 서버의 IP와 포트번호를 모르기 때문이다.(대리 프락시(리버스 프락시)랑 인터셉트 프락시는 아는건가?)

![스크린샷 2023-05-09 19.18.40.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0725b238-d7e7-46f1-b4f2-0425bad1feff/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_19.18.40.png)

## 6.5.2. 가상 호스팅에서 일어나는 같은 문제

위의 스킴/호스트/포트번호 누락 문제는 가상 호스팅에서도 문제가 된다. 클라이언트가 완전한 URI를 사용하거나 Host 헤더를 요구한다.

## 6.5.3. 인터셉트 프락시는 부분 URI를 받는다.

인터셉터는 원 서버로 요청이 가기 전에 받아 자기가 처리하기 때문에 부분 URI인지 완전 URI인지 상관 없다.

## 6.5.4. 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다.

다목적 프락시 서버는 완전한 URI가 오든 부분 URI가 오든 적절하게 처리할 수 있어야 한다.

- 완전한 URI가 주어졌다면 프락시는 그것을 사용한다.
- 부분 URI가 주어졌으나 Host 헤더가 있다면, Host 헤더에서 원 서버의 이름과 호스트 포트를 얻는다.
- 부분 URI가 주어지고 Host 헤더도 없다면, 대리 프락시에서 찾거나, 인터셉터 프락시에서 찾는다.
- 그럼에도 완전 URI를 얻지 못하면 클라이언트에 실패 메세지를 보낸다. Host 헤더를 사용하라는 메시지일 것이다.

## 6.5.5. 전송 중 URI 변경

기본적으로 프락시 서버는 URI 변경을 하지 않는 것이 원칙이다. HTTP 포트를 명시적으로 :80 한다던가 잘못 사용한 예약 글자를 이스케이프 하는 것은 무해한 일 같지만, 어떤 부작용을 만들어낼지는 아무도 모른다. 그리고 그런 역할을 프락시가 맡거나 가진 것은 아니다. HTTP 명세에도 URL을 전달할 때 절대 경로 고치는 것을 금하지만 예외로 빈 경로를 ‘/’로 교체하는 것은 허용한다.

## 6.5.6. URI 클라이언트 자동확장과 호스트 명 분석

크롬 같은 경우 google만 입력해도 www.google.com을 완성해준다. 알아서 .com 접미사를 붙여 해석할 수 있는 URI 형태로 고친다.

## 6.5.7. 프락시 없는 URI 분석

예를 들어 google을 브라우저에 입력하면 https://google:80/ 이렇게 찾는다. 실패하면 http://www.google.com:80/ 찾고 성공한다.

![스크린샷 2023-05-09 19.35.04.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ede1f29f-d699-4ffc-9fe0-700c9734aba0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_19.35.04.png)

## 6.5.8. 명시적인 프락시를 사용할 때의 URI 분석

명시적으로 프락시를 사용하면 위(6.5.6, 6.5.7)의 확장을 수행하지 않는다. 브라우저의 URI가 그냥 지나쳐버리기 때문이다. 다만 몇몇 프락시는 자동 확장을 흉내 내려고 시도한다.

![스크린샷 2023-05-09 22.00.07.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a5e379a-416f-4445-965a-453fd4eba718/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_22.00.07.png)

## 6.5.9 인터셉트 프락시를 이용한 URI 분석

보이지 않는 인터셉트 프락시가 있다면 클라이언트 입장에서는 존재하지 않는(모르는) 것이다. 이때 그 전에 커넥션이 만들어진 커넥션(트래픽)을 인터셉터 프록시가 가로챘었고, 인터셉트 프록시가 원 IP 주소와 포트번호를 사용할수 있었다면 클라이언트는 성공 적으로 웹 서버와 대화했다 믿지만 실제로 서버는 죽어 있을수 있다.

![스크린샷 2023-05-09 22.16.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/124b7dfd-1992-4660-a34b-2673c78cccc7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_22.16.20.png)

# 6.6. 메시지 추적

오늘날 통신 효율을 위해 프락시를 사용한다. 프락시를 넘나드는 메시지의 흐름을 추적하고 문제점을 찾는 일도 필요하다.

## 6.6.1. Via 헤더

프락시 서버는 자신을 통하는 메시지에 Via 헤더 값에 자신을 추가 해줘야 한다.

![스크린샷 2023-05-09 22.19.16.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/44c2373b-2c36-476d-9325-44a87bd01be4/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_22.19.16.png)

## 6.6.2. TRACE 메서드

클라이언트는 TRACE 메서드를 통해 메시지가 원 서버로 가는 사이에 있는 서버들을 추적할 수 있다.

![스크린샷 2023-05-09 22.20.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2ecb8c52-faa1-4f30-8985-a0ca5545076e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_22.20.08.png)

프락시 루프에 빠질 수도 있다. 이를 위해 Max-Forwards 라는 옵션도 있다.

![스크린샷 2023-05-09 22.22.34.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5dcc0cd6-de9d-422b-83b3-adc965ea8f4f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_22.22.34.png)

# 6.7. 프락시 인증

프락시 쪽에서 접근 제어를 할 수 있다. Proxy-Authenticate 헤더 값을 사용하는 것인데, 널기 구현돼 있지는 않아 사용성은 떨어진다.

# 6.8. 프락시 상호운용성

클라이언트와 서버 사이에 올바른 통신을 도우는 역할이다.

## 6.8.1. 지원하지 않는 헤더와 메서드 다루기

프락시 서버가 모든 헤더를 이해하지 못할 수 있다. 그럼에도 불구하고 적절히 처리한 후 다음 홉에 전달할 의무가 있다.

## 6.8.2. OPTIONS: 어떤 기능을 지원하는지 알아보기

OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해준다.

![스크린샷 2023-05-09 22.26.36.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7db727f2-ab89-40e1-9cfb-74f78f18cc1a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-09_22.26.36.png)

## 6.8.3 Allow 헤더

실제 지원하는 메서드를 Allow 엔티티 헤더에 넣어서 응답하라고 한다.

Allow: GET, HEAD, PUT

다만 이 부분은 구현 안된 경우가 많다.
