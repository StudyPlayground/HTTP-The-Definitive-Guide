# 15. 엔터티와 인코딩

HTTP는 매일 수십억 개의 미디어 객체를 실어 나르는 한편, 메시지가 올바르게 수송, 식별, 추출, 처리되는 것을 보장한다.

- 객체는 Content-Type 미디어 포멧과, Content-Language 헤더를 이용해 올바르게 식별된다. 이로 클라이언트에서 콘텐츠를 바르게 처리 가능하다.
- 객체는 Content-Length, Content-Encoding 헤더를 이용해 올바르게 압축이 풀릴 것이다.
- 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용).
- 사용자의 요구를 만족할 것이다(내용 협상을 위한 Accept 관련 헤더들에 기반).
- 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용).
- 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 Content-MD5 체크섬 이용).

이 장에서는 다음을 다룬다.

- HTTP 데이터를 담는 컨테이너인 HTTP 메시지 엔터티의 포맷과 동작방식
- 어떻게 HTTP가 엔터티 본문의 크기를 기술하며, 크기를 측정하기 위해 HTTP가 무엇을 요구하는지
- 클라이언트가 콘텐츠를 바르게 처리할 수 있도록 제공하는 엔터티 헤더들
- 공간을 적게 차지하고 더 안전하게 만들기 위해 발송자가 콘텐츠 데이터 포맷을 변형할 때 사용하는, 디코딩 가능한 콘텐츠 인코딩
- 특정 종류의 콘텐츠의 송수신을 개선하기 위해 HTTP가 데이터를 실어 나르는 방식을 수정하는 전송 인코딩. 그 중에서도 길이를 알 수 없는 콘텐츠를 안전하게 전송하기 위해 데이터를 여러 조각으로 쪼개 전달하는 청크 인코딩
- 클라이언트가 요청한 콘텐츠의 최신 버전을 가져올 수 있도록 도와주는 태그, 라벨, 시간, 체크섬의 모음
- 콘텐츠의 버전 번호처럼 동작하는 검사기들. 그리고 객체를 최신으로 유지하기 위해 설계된 HTTP 헤더 필드들
- 중단되었던 다운로드를 중단된 지점에서부터 재개하고자 할 때 유용한 범위 요청
- 클라이언트가 전에 본 적이 있었던 웹 페이지를 다시 볼 때, 그때 이후로 변경이 있는 부분만 요청할 수 있게 해주는 HTTP 델타 인코딩 확장
- 엔터티 콘텐츠가 프락시를 지나는 과정에서 변경된 곳이 있지 않은지 탐지하기 위해 사용하는, 엔터티 본문의 체크섬

# 15.1. 메시지는 컨테이너, 엔터티는 화물

메시지의 헤더에는 엔터티에 대한 많은 정보가 있다.

Content-Type : 엔터티에 의해 전달된 객체의 종류

Content-Length : 전달되는 메시지의 길이나 크기

Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어

Content-Encoding : 객체 데이터에 대해 행해진 변형

Content-Location : 요청 시점을 기준으로, 객체의 또 다른 위치

Content-Range : 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다.

Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크 섬

Last-Modified : 서버에서 이 콘텐츠가 생성 혹은 수정된 날

Expires : 이 텐터티 데이터가 더 이상 최신이 아닌 것으로 간주되기 시작하는 날짜와 시각

Allow : 이 리소스에 대해 어떤 요청 메소드를 허용하는지

ETag : 엄밀하게는 헤더 엔터티가 아니지만, 인스턴스에 대한 검사기로 사용된다.

Cache-Control : 어떻게 이 문서가 캐시 될 수 있는지에 대한 지시자. 엄밀하게는 헤더 엔터티가 아님

## 15.1.1. 엔터티 본문

엔터티 본문에는 다양한 타입의 데이터가 올 수 있다. 이를 클라이언트에 설명하기 위해 Content-Type 헤더에 본문에 대한 타입을 알려준다.

# 15.2. Content-Length: 엔터티의 길이

엔터티의 본문 길이이다. 만약 gzip으로 압축된 텍스트 파일이라면 압축 후의 크기다.

Content-Length는 청크 인코딩으로 전송하지 않는 이상 항상 포함 시켜야 한다.

## 15.2.1. 잘림 검출

Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지, 전송 중 서버에 충돌이 난 것인지 구분하지 못한다. 특히 메시지 잘림을 감지 못한 캐시 프락시 서버가 있다면 취약하다.

## 15.2.2. 잘못된 Content-Length

없느니만 못하다.

## 15.2.3. Content-Length와 지속 커넥션

지속 커넥션은 하나의 커넥션으로 다양한 메시지를 주고 받는다. 새로 받은 메시지의 인덱스(끝과 시작점)를 알고 있으려면 길이를 통해 계산을 해야 한다. 그런 이유로 지속 커넥션에서 Content-Length에 대한 의존성은 크다.

## 15.2.4. 콘텐츠 인코딩

HTTP는 보안을 강화하거나 압축을 통한 효율적인 통신을 하기 위해 본문을 인코딩한다.

## 15.2.5. 엔터티 본문 길이 판별을 위한 규칙

1. HEAD 메서드와 같이 본문이 없을 경우에는 Content-Length 헤더를 무시한다.
2. 메시지가 Transfer-Encdoing 헤더를 포함하고 있다면 엔터티는 '0바이드 청크'라고 불리는 특별한 패턴으로 끝나야 한다.
3. Transfer-Encoding 헤더 필드를 포함하면 Content-Length를 무시해야 한다. 이유는 전송 인코딩은 엔터티 본문을 표현한 후 전송하는 방식을 바꿀 것이기 때문이다.
4. 메시지의 타입이 'multipart/byteranges' 면 메시지의 각 부분의 크기를 스스로 정할 것이다. 이 유형은 유일하게 자신의 크기를 스스로 결정한다.
5. 엔터티는 커넥션이 닫힐 때 끝난다. 실직적으로 서버만이 메시지가 끝났음을 알리기위해 커넥션을 닫을 수 있다. 클라이언트는 절반 끊기를 할 수 있지만 커넥션을 닫을 수 없다. 그렇게 닫아버리면 서버가 응답을 돌려줄 방법이 없기 때문이다.
6. Content-Length가 포함되지 않은 요청에 대해서 411 Length Required 응답을 줘라고 조언한다.

# 15.3. 엔터티 요약(다이제스트?)

HTTP가 TCP/IP 위에서 신뢰할 만한 통신을 보장한다고 하지만, 중간에 프락시도 있고 여러 이유로 메시지가 변형되는 일이 있을수 있다. 이런 상황을 감지하고자 체크섬을 사용하기도 한다.

Content-MD5 헤더는 미리 서버가 만든 계산 된 값을 클라이언트에게 보낸다. 클라이언트는 메시지를 인코딩하여 Content-MD5 값과 비교하여 메시지가 정상적으로 도착했다는 것을 알 수 있다.

하지만 실제로 자주 사용되진 않는다.

다만 HTTP 확장들은 클라이언트가 응답에 대해 기대하는 다이제스트 유형을 정의할 수 있는 새로운 헤더인 Want-Digest를 제안했고, 이 헤더의 품질값(quality value)을 이용해 여러 다이제스트 알고리즘을 제안하고 각각에 대한 선호도를 지정 가능하다.

# 15.4. 미디어 타입과 Charset

Content-Type 헤더 필드에는 MIME 타입을 기술한다. MIME 타입은 주 타입/부 타입으로 구성되어 있는데 대표적인 예시는 아래와 같다.

```tsx

```

`text/html`, `text/plain`, `image/gif`, `image/jpeg`, `audio/x-wav`, `model/vrml`, `multipart/byteranges`, `message/http`

## 15.4.1. 텍스트 매체를 위한 문자 인코딩

다음 처럼 선택적으로 매개변수를 추가적으로 넣을 수 있다.

Content-Type: text/html; charset-iso-8859-4

## 15.4.2. 멀티파트 미디어 타입

서로 붙어 있는 여러 개의 메시지를 포함하며, 하나의 복합 메시지로 보내진다.

## 15.4.3. 멀티파트 폼 제출

boundary를 사용하여 각 파트를 구별할 수 있다.

```html
<form action="http://server.com/cgi/handle" enctype="multipart/form-data" method="post">
  <p>
    What is your name?
    <input type="text" name="submit-name" /> What files are you sending?
    <input type="file" name="files" />
    <input type="submit" value="Send" />
    <input type="reset"></input>
  </p>
</form>
```

만약 사용자가 입력 필드에 Sally를 입력하고 essayfile.txt를 선택 했다면, 사용자 에이전트는 아래와 같은 데이터를 돌려보낼 것이다.

```tsx
Content-Type: multipart/form-data; boundary=AaB03x --AaB03x
Content-Disposition: form-data; name="submit-name" Sally
--AaB03x
Content-Disposition: form-data; name="files"; filename="essayfile.txt" Content-Type: text/plain
...contents of essayfile.txt...
--AaB03x--
```

## 15.4.4. 멀티파트 범위 응답

응답 또한 멀티파트가 될 수 있다. 그 응답은 Content-Type: `multipart/byteranges` 헤더 및 각각 다른 범위를 담은 멀티파트 본문이 함께 온다.

# 15.5. 콘텐츠 인코딩

효율적인 통신이나 보안을 위하 발송자 쪽에서 콘텐츠를 인코딩하여 수신자에게 보낼 수 있다.

## 15.5.1. 콘텐츠 인코딩 과정

인코딩 서버(원 서버, 다운스트림 프락시) 원본 길이를 포함한 내용을 압축(gzip)한다. 이 메시지는 Content-Type은 같지만 압축 됐다면 Content-Length는 다르다. 또한 Content-Encoding 헤더를 메시지에 추가하여 수신자가 디코딩 할 수 있도록 한다.

## 15.5.2. 콘텐츠 인코딩 유형

gzip, compress, delate, identify 가 있지만 gzip이 가장 효율이 좋다고 한다. 모두 무손실 압축 알고리즘이다.

brotli 라는 것도 있는데 구글이 공개한 압축 알고리즘으로 gzip 보다 더 적은 용량으로 압축한다고 한다.

## 15.5.3. Accept_Encoding 헤더

클라이언트가 처리 가능한 인코딩 방식을 명시한다.

```tsx
Accept-Encoding: gzip; q=1.0, brotli; q=0.5 *;q=0
```

위에서 q는 선호도를 나타낸다. gzip을 가장 선호 brotli는 0.5만큰 선호 나머지는 싫다는 뜻이다.

# 15.6. 전송 인코딩과 청크 인코딩

text에 대해서 gzip은 꽤 효율적이다. 그런데 JPEG 같은 이미지는 gzip으로 잘 압축되지 않는다. 전공 인코딩은 포맷과는 독립적이지만 메시지 데이터가 네트워크를 통해 전송되느 방법을 바꾸기 위해 사용한다.

## 15.6.1. 안전한 전송

전송 인코딩은 안전한 전송을 위해 존재 했다. 전송 인코딩을 사용 하는 주요 이유는 두 가지로, 메시지에 Content-Length를 포함하지 않는 경우 몇몇 게이트 웨이나 서버는 전송 인코딩으로 데이터를 보내려 한다. 또 다른 이유는 보안의 이유다. 이 경우는 SSL의 등장으로 거의 사용하지 않는다.

## 15.6.2. Transfer-Encoding 헤더

Transfer-Encoding - 어떤 인코딩을 적용했는지 수신자에게 알린다.

TE - 어떤 전송 인코딩을 사용할 수 있는지 서버에 알린다.

## 15.6.3. 청크 인코딩

메시지를 여러 청크로 쪼갠다. Content-Length를 따로 알려주지 않고 일정 크기의 청크를 계속 보내다 다 보내면 마지막에 크기가 0인 청크를 보낸다.

이때 411 Length Required 응답으로 거절당하지 않도록 해야한다.

마지막 청크 다음에는 트레일러를 추가할 수 있다. 클라이언트의 TE 헤더가 트레일러를 받아들일 수 있음을 명시하거나 응답을 만든 서버에 의해 추가 됐지만 트레일러는 클라이언트가 사용할 필요가 없는 옵셔널한 메타데이터이므로 클라이언트가 무시하고 버려도 될 경우 추가할 수 있다.

## 15.6.4. 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용할 수 있다.

## 15.6.5. 전송 인코딩 규칙

- 전송 인코딩의 집합은 반드시 chucked를 포함해야 한다. 유일은 예외는 메시지가 커넥션의 종료로 끝나는 경우뿐 이다.
- 청크 전송 인코딩이 사용됐다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 인코딩은 반드시 메시지 본문에 한번 이상 적용돼야 한다.

# 15.7. 시간에따라 바뀌는 인스턴스

웹 객체는 정적이지 않으므로 현재의 서버 응답과 다음의 서버 응답이 다를 수 있다.

# 15.8. 검사기와 신선도

이 전 응답으로 받은 데이터와 현재 받을 데이터가 동일하면 새로 받을 필요가 없다. 요청 헤더 쪽에서 다뤘던 내용이다.

## 15.8.1.

Expires, Cache-Control 헤더를 통해 신선도를 체킹할 정책을 정한다.

## 15.8.2. 조건부 요청과 검사기

If-Modified-Since 헤더 등을 사용,

약한 검사, 강한 검사기(ETag)

# 15.9. 범위 요청

브라우저에서 어떤 데이터를 다운로드 받을 때 데이터의 변화가 있을 때만 새로 보내달라고 요청한다. HTTP는 추가적으로 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.

```tsx
GET /bigfile.html HTTP/1.1
Host: www.joes-hardware.com
Range: bytes=4000-
User-Agent: Mozilla/4.61 [en] (WinNT; I)
...
```

# 15.10 델타 인코딩

어떤 문서의 일부분이 변경돼 새로운 데이터를 요청 할 때, 변경된 부분만 받는다면 최적화 할 수 있다.