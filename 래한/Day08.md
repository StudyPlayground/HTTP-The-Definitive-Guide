# 13. 다이제이스 인증

기본 보안을 안전하게 이용하는 유일한 방법은 SSL과 결합해서 사용하는 것이다.

다이제스트 인증은 현재 널리 쓰이지는 않지만 개념은 보안 트랜젝션을 구현하고자 할때 여전히 유용하다. 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체재로서 개발 됐다.

# 13.1. 다이제스트 인증의 개선점

다이제스트 인증은 기본 인증의 결함을 수정한 또 다른 HTTP 인증 프로토콜이다.

- 비밀번호를 절대 네트워크를 통해 평문으로 전송하지 않는다.
- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
- 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
- 그 외 몇몇 잘 알려진 형태의 공격을 막는다.

다이제스트 인증은 기본 인증보다 강력하지만, 전송 계층 보안(TLS)과 보안 HTTP(HTTPS)가 더 적합한 프로토콜이다.

### Ref. 다이제스트 = 요약 으로 바꿔서 글을 적겠다.

다이제스트는 본문의 압축이다. 어떤 값이 오면 32글자의 16진수 문자로 표현한다.

비밀번호를 모른다면 알맞은 다이제스트을 추측하기 어렵고, 다이제스트를 추측하더라도 어떤 값을 통해 해당 다이제스트를 생성했는지 모른다.

요약 함수는 암호 체크섬으로 불리며, 단방향 해시 함수이거나 지문 함수이다.

단방향 다이제스트의 경우 다이제스트를 가로채서 재전송 한다면 비밀번호를 갈취 당한 것과 다름 없다. 이를 위해 서버에서 난스(nonce)를 보내주고 매번 새로운 다이제스트를 만들도록 한다.

## 13.1.4. 다이제스트 인증 핸드셰이크

![스크린샷 2023-06-12 오후 7.52.13.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/763e36c0-7a37-43e3-8619-362e9accf82e/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.52.13.png)

# 13.2. 요약 계산

다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 다이제스트이다.

# 14. 보안 HTTP

이 장에서 다룰 것

- 암호화 기법과 용어 정리.
- 서버 인증서, 디지털 인증서는 무엇이고, 어떻게 서로 신뢰할 수 있는지.
- HTTP에서 보안상 안전하게 메시지를 보내기 위해 사용하는 SSL, TLS의 동작을 이해.

# 14.1. HTTP를 안전하게 만들기

웹 트랜잭션을 통해 은행 업무, 쇼핑 등 더 많은 일을 하기 위해서는 강력한 보안이 필요하다. 앞서 다룬 인증들은 충분히 강력하지 않다. 중요한 트랙젝션을 위해 HTTP와 디지털 암호화 기술을 결합해야 한다.

우리는 아래와 같은 기능을 제공해주는 HTTP 보안 기술이 필요하다.

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜 서버와 이야기 하는 것이 보장되어야 한다.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기 하는 것이 보장되어야 한다.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야 한다.
- 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성 - 현재 알려진 최선의 보안 방법을 지원해야 한다.
- 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

## 14.1.1. HTTPS

안전한 웹 통신 프로토콜로 넷스케이프에서 개척 했다. 프로토콜 스킴은 HTTPS다.

![스크린샷 2023-06-12 오후 9.01.35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/12cf9f55-3e10-45e1-b2d5-5fbe7181e9c2/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.01.35.png)

모든 HTTP 요청과 응답 데이터는 보내지기 전에 암호화된다. HTTP와 TCP 사이에 하나의 계층이 추가가 되는데 SSL(Secure Sockets Layer)와 TLS(Transport Layer Security)이고 명확히 TLS는 SSL을 확장 시킨 것이기에 두 가지 모두를 SSL이라 통칭해서 설명한다.

인코딩, 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나고, 대부분의 경우 TCP 입/출력 호출을 SSL 호출로 대체하고 보안 정보를 설정하고 관리를 위한 호출을 추가하면 된다.

# 14.2. 디지털 암호학

- 암호 - 텍스트를 아무나 읽지 못하도록 인코딩 하는 알고리즘
- 키 - 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계 - 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계 - 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법 - 비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명 - 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서 - 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인 정보

## 14.2.1. 비밀 코드의 기술과 과학

암호법(cryptography)은 과학이자 기술(art)이다.

예를 들어 SHA256은 유명한 Cryptography(암호법, 암호화 방식, 암호화 기법) 이다.

## 14.2.2. 암호(cipher)

암호는 메시지를 인코딩 하거나 디코딩 하는 방법(일련의 알고리즘)이다.

암호가 적용되기 전의 메시지를 평문, 적용된 후의 메시지를 암호문이라 부른다.

![스크린샷 2023-06-12 오후 10.13.00.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8e7de40-58e2-4c7e-9e3f-099882cbcf1d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.13.00.png)

![글자를 3개씩 뒤로 미루는 rot3](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0467403f-3501-489c-805e-b4c1e79dd913/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.12.10.png)

글자를 3개씩 뒤로 미루는 rot3

## 14.2.3. 암호 기계

암호를 만들고 해독하는 기계.

## 14.2.4. 키가 있는 암호

암호 기계가 하나라도 적의 손에 들어간다면 모든 기계를 바꿔야 한다. 이를 방지하기 위해 암호의 동작 방식을 변경할 수 있는 숫자로 된 다이얼이 있었다. 이런 암호 매개변수를 키라고 부른다. 키를 모른다면 디코딩 할수 없다.

![스크린샷 2023-06-12 오후 10.17.03.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c598d62a-1fd8-47f4-948f-459646e8f5db/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.17.03.png)

## 14.2.5. 디지털 암호

디지털 계산으로 두 가지 주요한 발전이 있었다.

- 복잡한 인코딩과 디코딩 알고리즘을 수행할 수 있다.
- 매우 큰 키를 사용할 수 있다.

![평문은 인코딩 키 e로 인코딩되고, 디코딩 키 d로 디코딩 된다.](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cfd484f9-75ff-4f67-8a18-8287711e5428/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_10.17.46.png)

평문은 인코딩 키 e로 인코딩되고, 디코딩 키 d로 디코딩 된다.

## 14.3. 대칭키 암호법

인코딩할 때와 디코딩할 때 키가 같으면 대칭키라 한다. 잘 알려진 대칭키 암호 알고리즘은 DES, Triple-DES, RC2, RC4 등이 있다.

대칭키는 개인키 암호법이라고도 한다.

## 14.3.1. 키의 길이와 열거 공격

키를 모르더라도 모차별로 모든 키 값을 대입하면 암호가 깨질수 있다(열거 공격). 실제 컴퓨터는 빠르게 발전하고 있기 때문에 보안에 취약점이 있다고 본다. 키의 길이는 키를 만들 수 있는 경우의 수에 영향을 미치고 길수록 안전하다.

## 14.3.2. 공유키 발급하기

대칭키는 서로 통신하기위해 개인키를 만들어야 하는데 노드의 개수가 N개고 N-1과 대화를 나누려면 대략 N^2 만큼의 개인키가 필요하다. 키를 관리하는 것도 복잡해진다.

# 14.4. 공개키 암호법(비대칭키 암호법)

인코딩과 디코딩에 사용하는 키가 다르다. 인코딩 할 키는 공개되어 있고, 호스트만이 메시지를 디코딩하는 개인키를 가지고 있다.

키를 관리하는 일이 대칭키일 때보다 줄어든다. 노드가 N개 있을 때, 나의 개인키 하나와 N-1개의 공개키가 있으면 된다.

![스크린샷 2023-06-13 오후 1.16.09.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b43e0b36-29c7-4edb-bd31-e5a28b6ab713/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.16.09.png)

![스크린샷 2023-06-13 오후 1.16.26.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/22a49dd9-7de9-4ae9-9a59-e24a7c862ecc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.16.26.png)

## 14.4.1. RSA

공개키 비대칭 암호의 과제는 공개키를 소유한 해커가 다른 사람의 메시지(암호문)를 탈취(스누핑)해도 원래의 메시지를 알수 없도록 해야 한다는 것이다.

RSA는 이 문제를 해결하는 가장 유명한 알고리즘으로, 소수의 계산이 오래 걸린다는 사실을 착안하여 만든 알고리즘이다.

## 14.4.2. 혼성 암호 체계와 세션 키

공개키 알고리즘의 단점은 알고리즘의 계산이 느리다는 점이다. 그래서 고안한 것이 처음으로 보안 통신을 하려는 주체가 임의의 대칭키를 만들어 공개키로 암호화해서 보내면 다음부터는 대칭키를 사용하여 통신하는 방법이다.

# 14.5. 디지털 서명

암호 체계는 암호화, 복호화 뿐 아니라 누가 메시지를 썼는지, 그 메시지가 변조, 위조 되지 않았음을 증명하기 위한 서명에 이용될 수 있다. 이는 다음 장의 인터넷 보안 인증서에 중요하다.

## 14.5.1. 서명은 암호 체크섬이다.

서명은 저자의 극비 개인 키를 사용하며, 저자만이 개인키를 이용하여 체크섬을 계산 가능하다.

디지털 서명은 보통 비대칭 공개키에 의해 생성한다. 개인 키는 소유자만이 알고 있기 때문에 지문처럼 사용된다.

![스크린샷 2023-06-13 오후 1.59.12.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/63681bcc-5b79-4668-bc7a-a469aef6b849/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.59.12.png)

- A는 고정된 길이의 요약(digest)으로 만든다.
- A는 그 요약에, 사용자의 개인 키를 매개변수로 하는 '서명' 함수 D를 적용한다. 서명 함수를 디코더 함수를 사용한다.
- A는 디코더로 계산(위 과정)된 결과를 메시지의 끝에 덧붙이고 B에게 보낸다.
- B는 공개키로 서명을 인코더 함수로 푼다. B의 요약과 일치하지 않는다면 올바른 사용자가 아니라고 판단한다.

# 14.6. 디지털 인증서

CA(cert, Certificate Authority)에서 발급된 인증서.

## 14.6.1. 인증서의 내부

대상의 이름, 유효 기간, 인증서 발급자, 인증서 발급자의 디지털 서명을 담고 있다.

![스크린샷 2023-06-13 오후 3.08.12.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/56daa528-0295-437d-8c16-568a5474d435/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.08.12.png)

## 14.6.2. X.509 v3 인증서

디지털 인증서에 대한 전 세계적인 표준은 없지만, 대부분의 인증서는 X.509 라 불리는 표준화된 서식에 저장한다.

### 인증서 필드

- Version 인증서의 버전을 나타냄
- Serial Number(일련번호) - CA가 할당한 정수로 된 고유 번호
- Signature(서명 알고리즘 ID) - 서명 알고리즘 식별자
- Issuer 발행자, 발급자 - 인증서를 발급하고 서명한 기관의 이름.
- Validity 유효기간
    - Not Before 유효기간 시작 날짜
    - Not After 유효기간 끝나는 날짜
- Subject 소유자, 소유자의 이름
- Subject Public Key Info 소유자 공개 키 정보
    - Public Key Algorithm 공개 키 알고리즘
    - Subject Public Key
- Issuer Unique Identifier(Optional) 발행자 고유 식별자
- Subject Unique Identifier(Optional) 소유자 고유 식별자
- Extensions(Optional) 확장
- 인증기관 서명

[X.509](https://ko.wikipedia.org/wiki/X.509)

## 14.6.3. 서버 인증을 위해 인증서 사용하기

HTTPS를 통한 웹 트랙잭션을 사용한다면, 브라우저는 접속한 서버에서 디지털 인증서를 가져와 해석(검사)한다.

서버 인증서는 다음을 포함한다.

- 웹 사이트의 이름과 호스트 명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

특히 서명 기관은 CA로 널리 알려진 인증 기관으로, 브라우저에서는 여러 CA에 대한 정보가 미리 설치돼 있다. 크롬의 경우 자신이 알고 있는 CA면 바로 연결이 되고, 몰라도 사용자에게 한 번 더 물어본다.

![스크린샷 2023-06-13 오후 3.14.50.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cf4192a0-dbb1-4988-b642-9f9f9511e296/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-06-13_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.14.50.png)

# 14.7 HTTPS의 세부사항

HTTPS는 HTTP의 보안 버전이다. HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 집합을 결합한 것이다.

## 14.7.1. HTTPS 개요

HTTPS는 보안 전송 계층을 통해 전송되는 HTTP이다.

HTTP는 메시지를 TCP를 통해 보낸다면 HTTPS는 HTTP 메시지를 TCP로 보내기 전에 TLS로 구현된 보안 계층을 거친다.

## 14.7.2. HTTPS 스킴

HTTP, HTTPS는 필요에 따라 사용하고 보통은 둘 다 사용할 수 있게 하거나 보안 연결만 가능하게 한다.

https로 접근하면 바이너리 포멧으로 된 SSL 보안 매개변수를 교환하면서 핸드셰이크 한 후, 암호화된 HTTP 명령을 보낸다.

## 14.7.3. 보안 전송 셋업

HTTPS는 기존 HTTP 통신 절차보다 복잡한 과정을 거친다.

클라이언트가 HTTPS 로 접근을 하면 TCP 커넥션을 맺고 SSL 계층에서 암호 매개변수와 교환 키를 협상한다(핸드셰이크). SSL 초기화가 완료되었고, 클라이언트는 요청 메시지를 SSL을 통해 보낸다.SSL에서는 메시지를 암호화 해서 TCP를 통해 서버로 보낸다.

## 14.7.4. SSL 핸드셰이크

위의 SSL 계층에서 암호 매개변수와 교환 키를 협상하는 과정의 핸드 셰이크에서 다음과 같은 일이 일어난다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션 키 생성

## 14.7.5. 서버 인증서

오늘날 클라이언트 인증서가 아닌 서버 인증서를 통해 안전한 통신을 한다.

개인 클라이언트 인증서보다 잘 알려진 인증기관에 의해 서명된 서버 인증서를 통해 클라이언트에서 검증한다.

## 14.7.6. 사이트 인증 검사

사이트 인증서를 검사하는 과정은 날짜 검사, 서명자 신뢰도 검사, 서명 검사, 사이트 신원 검사를 포함한다.

### 날짜 검사

인증서가 유효한지 시작 및 종료일을 검사한다.

### 서명자 신뢰도 검사

### 서명 검사

서명 기관이 믿을만하면, 브라우저는 서명 기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.

### 사이트 신원 검사

## 14.7.7. 가상 호스팅과 인증서

하나의 서버에 여러 호스트(가상 호스트)로 운영되면 까다로울 수 있다.

# 14.8. 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜이라 사용하는데 어려울 수 있다. 상용, 오픈 소스 라이브러리를 이용하자.

## 14.8.1. OpenSSL

SSL과 TLS의 가장 인기있는 오픈소스 구현체다.

## 14.8.2. 간단한 HTTPS 클라이언트

## 14.8.3. 단순한 OpenSSL 클라이언트 실행하기

# 14.9. 프락시를 통한 봔 트래픽 터널링

SSL은 바이너리 프로토콜이다. 프락시는 암호화된 메시지를 받는다. 프락시는 메시지의 헤더에서 어디로 전성되어야 하는지 알아야하는데 암호화 됐기 때문에 읽어낼 수 없다. 이 때 HTTPS SSL 터널링 프로토콜을 사용한다.

HTTP는 CONNECT라는 확장 메서드를 사용해 어디로 갈지 명시한다.

```tsx
CONNECT home.netscape.com:443 HTTP/1.0
User-agent: Mozilla/1.1N
```

프락시는 이 CONNECT 메서드를 받으면 직접 대상으로 연결시켜주는 터널을 만들어 준다.