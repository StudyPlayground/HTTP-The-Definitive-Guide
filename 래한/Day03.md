# 4. 커넥션 관리

이번 장에서 다루는 내용

- HTTP는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬 커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

# 4.1. TCP 커넥션

HTTP 통신은 네트워크 장비에서 사용하는 전송/네트워크 프로토콜인 TCP/IP를 통해 이뤄진다. TCP/IP 위에서 전송되기 때문에 메시지의 무결성, 순서를 보장할 수 있고 이런 특징을 신뢰성 있는 연결이라 한다.

- 예시) https://www.kakao.com 을 방문하면 일어나는 일.
    1. 브라우저가 www.kakao.com 이라는 호스트명을 추출(뒤의 패스도 무시)
    2. 브라우저가 이 호스트 명에 대한 IP 주소를 얻는다.
    3. 브라우저가 포트 번호(443, https)를 얻는다.
    4. 브라우저가 받은 IP주소의 443 포트로 TCP 커넥션을 생성한다.
    5. 브라우저가 서버로 HTTP GET 요청 메시지를 보낸다.
    6. 브라우저가 서버에서 온 HTTP 응답 메시지를 읽는다.(응답을 읽음)
    7. 브라우저가 커넥션을 끊는다.

## 4.1.1. 신뢰할 수 있는 데이터 전송 통로인 TCP

HTTP 커넥션은 몇가지 규칙이 추가된 TCP 커넥션이다. 그렇기 때문에 TCP 커넥션에 대한 이해가 있어야 HTTP 커넥션을 이해할수 있다. TCP 커넥션은 한쪽에 있는 바이트(데이터)들을 반대 쪽으로 정확히 전달한다.

## 4.1.2. TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

TCP는 IP 패킷(or IP 데이터그램)이라 불리는 조각을 통해 데이터를 전송한다. TCP와 관계된 프로토콜 스택은 아래와 같다.

![스크린샷 2023-05-02 오후 4.07.24.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6edd13d3-c8b2-4072-89fc-aea77c8001af/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.07.24.png)

TCP는 세그먼트 단위로 데이터 스트림을 나누고, 나눈 세그먼트를 IP 패킷으로 감싸 인터넷을 통해 전달한다. 모든 과정은 TCP/IP 소프트웨어에 의해 잘 처리되기 때문에 프로그래머가 할 것은 없다.

아래 그림을 보면 3장에서 나온 HTTP 메시지가 TCP 데이터 스트림 청크로 들어가 있고, 그것을 TCP 세그먼트가 감싸고, 또 그 세그먼트를 IP 패킷으로 감싸 전달된다.

![스크린샷 2023-05-02 오후 4.15.42.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/341096ba-17a5-4a94-9094-48f4162dd7dc/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.15.42.png)

## 4.1.3. TCP 커넥션 유지하기

TCP는 포트 번호를 통해 여러 개의 커넥션을 유지한다. IP는 해당 컴퓨터에 연결되고, 포트 번호는 해당 애플리케이션으로 연결된다.

TCP 커넥션은 네 가지 값으로 식별한다.

- 발신지 IP 주소
- 발신지 포트
- 수신시 IP 주소
- 수신지 포트

위 값이 모드 같은 커넥션은 존재할수 없기 때문에 유일한 커넥션을 생성한다.

예를 들어 구글 탭을 하나 띄워 놓고 새 탭으로 구글에 접속하면 내 IP 주소는 같지만, 다른 포트 번호로 요청을 한다. 심지어 성능 향상을 위해 구글에 접속 했을 때 다중 커넥션을 만들어 여러 데이터를 동시에 받게 되는데, 이때 여러 포트로 커넥션을 만들게 된다.

## 4.1.4. TCP 소켓 프로그래밍

운영체제 차원에서 TCP 커넥션 생성과 관련된 기능을 제공한다.

![스크린샷 2023-05-02 오후 4.42.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4929e305-b5a3-4751-82bc-0a3c9a67f000/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.42.47.png)

소켓 API를 사용하면 TCP 종단 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 생성한 종단 데이터 구조를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

TCP API는 기본적인 네트워크 프로토콜의 핸드쉐이킹, TCP 데이터 스트림과 IP 패킷 간 불할 및 재조립에 대한 모든 세부사항을 외부로부터 숨긴다.

![스크린샷 2023-05-02 오후 4.45.54.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d7056678-e273-46ce-99c1-12cead397af6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.45.54.png)

# 4.2. TCP의 성능에 대한 고려

HTTP 트랙잭션의 성능은 아래 계층인 TCP 성능에 영향을 받는다. 즉 TCP 커넥션의 성능에 대한 이해가 있다면 HTTP 통신의 최적화를 더 잘 이해할수 있다.

## 4.2.1. HTTP 트랙잭션 지연

보통의 경우 통신에서 TCP 커넥션을 설정하고, 요청을 전송하고, 처리하여, 응답 메세지를 받는 과정에서 처리가 차지하는 비중은 상당히 짧다. 즉 대부분의 HTTP 지연은 TCP 네트워크 지연 때문에 발생한다.

![스크린샷 2023-05-02 오후 5.04.16.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3779756c-a10b-4001-94a0-e8d5ccfa5785/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.04.16.png)

1. 클라이언트는 도메인 네임으로 IP 주소와 포트 번호를 알아내야한다. 접근한 기록이 없다면 DNS를 거쳐야 한다.
2. 서버에 TCP 커넥션 요청을 보낸다.
3. 커넥션이 맺어지면 HTTP 요청을 생성된 TCP 파이프를 통해 전송한다. 서버는 그 메시지를 읽고 처리한다.
4. 웹 서버에 응답을 보낸다.

## 4.2.2. 성능 관련 중요 요소

- TCP 커넥션의 핸드셰이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한 번에 전송하기 위한 네이글(nagle) 알고리즘
- TCP의 편승(piggyback), 확인응답(acknowledgment)을 위한 확인응답 지연 알고리즘
- TIME_WAIT 지연과 포트 고갈

## 4.2.3. TCP 커넥션 핸드셰이크 지연

TCP 커넥션을 열 때 조건을 맞추기 위해 클라이언트와 서버는 IP 패킷을 교환한다.(오늘날의 TCP는 마지막 클라이언트의 확인 응답 패킷과 함께 데이터를 보낼 수 있다.)

![스크린샷 2023-05-02 오후 5.17.23.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b05c3f5-9be5-4aff-bca1-cf7981546f17/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.17.23.png)

HTTP 프로그래머는 이 패킷을 보지 못한다. 커넥션을 생성하는데 3번의 네트워크 비용이 발생하고, 특히 큰 데이터가 아니라면 이 핸드셰이크가 눈에 띄는 지연을 발생시킨다. 매번 커넥션을 만들지 않고 재활용 해야한다.

## 4.2.4. 확인응답 지연

인터넷 자체카 패킷 전송을 완벽히 보장하진 않기 때문에(인터넷 라우터는 과부하에 걸렸다면 패킷을 망므대로 파기할 수 있다), TCP는 자체적인 확인 체계를 가진다.

각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다. 각 세그먼트의 수신자는 온전히 받았다는 의미로 확인응답(ACK) 패킷을 송신자에 반환한다. 이 값은 하나의 비트기 때문에(크기가 작기 때문에) 이것만을 위한 패킷을 만들기에는 아깝다. 그래서 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승(piggyback, 동승) 시킨다.

확인응답 지연은 효율적으로 확인응답을 보내기 위해 편승할 패킷을 위해 기다리는 행위로, 일정시간 기다리다 늦어지면 별도의 패킷을 만들어 전송한다.

## 4.2.5. TCP 느린 시작(slow start)

패킷의 전송속도는 네트워크 대역폭에 따라 결정된다. 너무 많은 데이터를 보내서 대역폭이 감당 하지 못하면 문제가 발생하기 때문에 안전을 위해 성공을 하면 대역폭을 2배씩 늘려나간다. 이렇게 이미 데이터를 주고 받은 튜닝된 커넥션이 새 커넥션보다 빠르기 때문에, HTTP에는 이미 존재하는 커넥션을 재사용하는 기능이 있다.

<aside>
💡 네트워크 대역폭(bandwidth) vs 네트워크 출력(throughput)
네트워크 출력은 속도와 관련 있고 대역폭은 용량과 관련 있다. 즉 데이터가 이동하는 파이프의 갯수와 관계 있다.

</aside>

<aside>
💡 what is window?
sender(보통의 경우 클라이언트)가 보낼 수 있는 최대 데이터 크기.
상황에 따라 데이터가 소비되는 속도가 다르기 때문에 빈 공간은 때에 따라 다르다. 그래서 reciever는 sender에게 계속 window size를 알려줘야 한다.

</aside>

## 4.2.6. Nagle 알고리즘과 TCP_NODELAY

TCP 데이터는 단 1바이트라도 전송 가능한데, TCP 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하므로, 하나의 큰 데이터보다 여러개의 작은 데이터를 전송할 때 성능이 떨어진다.

네이글 알고리즘은 패킷 전송전 여러 TCP데이터를 합쳐, 일정 크기가 되면 전송을 한다. 만약 일정 크기가 되지 않아도 모든 패킷이 확인 응답을 받았을 경우에는 전송을 허락한다.

네이글 알고리즘은 두가지 문제가 있는데 첫 번째는 크기가 작은 메세지일 경우 패킷을 채우지 못해 추가 데이터를 기다리며 지연된다. 두 번째는 확인응답 지연과 함께 쓰일경우 네이글 알고리즘은 확인 응답이 도착할 때까지 데이터 전송을 멈추게하고, 확인응답 지연 알고리즘은 확인 응답을 100~200ms 지연시킨다.

## 4.2.7. TIME_WAIT의 누적과 포트 고갈

TCP 커넥션을 끊으면 종단에서는 커넥션의 IP 주소와 포트번호를 메모리의 작은 제어 영역에 기록해 둔다. 같은 주소와 포트번호를 사용하는 새 TCP 커넥션이 일정시간 생성되지 않게 하기 위함으로 약 2분(2MSL, 최대 생명 주기) 유지 된다.

발신지의 포트수를 2^16이라 하고 약 2분 재사용 할수 없다면 초당 500개(60,000/120)로 커넥션이 제한된다. 서버가 초당 500개 이상의 트랜잭션을 처리하지 않는다면 TIME_WAIT 포트 고갈은 일어나지 않지만, 커넥션을 너무 많이 맺거나, 제어 블록이 대기 상태로 너무 많아지는 상황은 주의해야 한다.

# 4.3. HTTP 커넥션 관리

## 4.3.1. 흔히 잘못 이해하는 connection 헤더

HTTP 커넥션 헤더 필드는 커넥션 토큰을 쉼표로 구분하여 가지고 있으며, 그 값들은 다른 커넥션에 전달되지 않는다. 즉 모든 헤더 필드는 메시지를 다른 곳으로 전달하는 시점에 삭제야 한다.

커넥션 헤더는 다음 세 가지 값이 전달 된다.

1. HTTP 헤더 필드 명(흡별 헤더 명): 여기 적힌 헤더들은 모두 다른 곳으로 전달하는 시점에 삭제돼야 한다.
2. 임시적인 코튼 값: 커넥션에 대한 비표준 옵션.
3. close 값: 트랜잭션이 끝나면 커넥션이 끊길 것이라는 듯.

![스크린샷 2023-05-02 오후 7.49.55.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6743ad63-8670-4710-b750-14d4ad7f3a89/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-05-02_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.49.55.png)

커넥션에 대해 잘못 처리하는 서버가 있을 수 있고, 사이에 놓은 프락시 서버, 캐시 서버 같은 중개 서버에 적절히 처리를 못하기도 한다.

## 4.3.2. 순차적인 트랜잭션 처리에 의한 지연

HTTP 요청을 빠르게 주고 받기 위해 아래 네 가지 전략이 있다.

- 병렬 커넥션 - 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
- 지속 커넥션 - 커넥션을 맺고 끊는 데서 발생하는 지연을 제거하기 위한 TCP 커넥션의 재활용
- 파이프라인 커넥션 - 공유 TCP 커넥션을 통한 병렬 HTTP 요청
- 다중 커넥션 - 요청과 응답들에 대한 중재

# 4.4. 병렬 커넥션

## 4.4.1. 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

하나의 커넥션으로 데이터를 받을 때보다 대역폭 제한과 대기 시간을 줄일 수 있다.

다만 메모리를 많이 소모 한다.

## 4.4.2. 병렬 커넥션은 항상 더 빠르지는 않다.

네트워크 대역폭이 좁다면 어쩔수 없다. 그리고 대역폭이 좁다면 오히려 커넥션 사이의 지연이 발생하기 때문에 서버의 성능도 떨어뜨릴수 있다.(100명의 사용자가 100개의 커넥션을 맺는다면?)

그런 이유로 브라우저는 병렬 커넥션을 사용하지만 적은 수(보통 6~8개)의 병렬 커넥션만을 허용한다.

## 4.4.3. 병렬 커넥션은 더 빠르게 ‘느껴질 수’ 있다.

실제로 사용자들은 LPC보다 FPC를 더 중요하게 생각한다.

# 4.5. 지속 커넥션

커넥션을 한 번 사용 후 폐기하지 않고 재활용하는 것으로 HTTP/1.0+ 이상부터 사용 한다.

사이트 지역성(site locality, locality of reference)와 관련있다.

## 4.5.1. 지속 커넥션 vs 병렬 커넥션

병렬 커넥션 단점

- 커넥션 생성 비용
- slow-start
- 병렬 커넥션 수의 제한

지속 커넥션은 위의 제한을 커버할 수 있기 때문에 병렬 커넥션과 지속 커넥션을 함께 사용한다.

HTTP/1.0+ 에서는 keep-alive를 HTTP/1.1 부터 지속 커넥션을 사용.

## 4.5.2. HTTP/1.0+의 Keep alive 커넥션

지금은 deprecated 됐지만 여전히 사용하는 곳이 있기 때문에 지원해야 한다.

연속으로 커넥션을 생성하여 처리하는 것이 아닌, 하나의 지속 커넥션으로 처리한다.

## 4.5.3. Keep-Alive 동작

클라이언트에서 요청에 Connection:Keep-Alive 헤더를 포함 시키고, 서버에서도 헤더에 포함 시켜 응답하면 커넥션을 재활용한다. 만약 없다면 서버가 지원하지 않거나 서버가 끊고자 하는 것이다.

## 4.5.4. Keep-Alive 옵션

Keep-Alive 헤더는 커넥션을 유지하기를 바라는 요청으로 어떻게 할지 말지는 받는 쪽에서 결정하면 된다.

또한 옵션 값도 사용할 수 있다. timeout 파라미터는 얼마간 유지될지, max 파라미터는 몇 개의 HTTP 트랜잭션을 처리할 때까지 유지될 지 설정할 수 있지만 이대로 동작한다는 보장은 없다. 이름[=값] 같은 식으로 디버깅 목적의 속성을 지원하기도 한다.

## 4.5.5. Keep-Alive 커넥션 제한과 규칙

- keep-alive는 HTTP/1.0에서 기본 값은 아니다.
- 클라이언트가 keep-alive 요청을 했는데 서버가 keep-alive 응답이 없다면 지속 커넥션이 안되고, 클라이언트는 커넥션이 끊어질 것이라 예측한다. 즉 계속 요청 헤더에 포함시켜야 한다.
- keep-alive를 사용한다면 서버에서 정확한 content-length를 보내야 한다. 그렇지 않으면 트랜잭션이 끝나는 시점에 기존 메시지의 끝과 시작을 알수 없다.
- 클라이언트와 서버 사이에 중개 서버(프락시, 캐시)가 있을 수 있는데 keep-alive를 보르면 행이 걸릴수 있다.

## 4.5.6. Keep-Alive와 멍청한(dumb) 프락시

프락시에서 Connection Keep Alive 헤더를 이해하지 못한다면 이해하지 못한채 삭제하지 않고 그대로 다음 프락시에로 전달하는데, 문제는 그 후 그 프락시가 서버로부터 받은 응답을 클라이언트로 전달 후 서버가 커넥션을 끊기를 기다린다는 것이다. 이렇게되면 클라이언트와 서버는 커넥션을 끊지 않고 통신을 하려고 하는데, 프락시는 같은 커넥션에서 다른 요청이 오는 경우롤 예상 못하기 때문에 그 요청을 무시하고 브라우저는 응답을 받지 못한다.

이런 경우를 방지하기 위해 헤더를 그대로 전달하면 안된다.

## 4.5.7. Proxy-Connection 살펴보기

위의 멍청한 프락시 때문에 등장한 개념이다. Connection 헤더 대신 비표준인 Proxy-Connection 확장 헤더를 프락시에게 전달하면, 무조건 전달하더라도 서버는 비표준 헤더릴 무시하기 때문에 문제되지 않는다.

멍청한 프락시는 Proxy-Connection 값을 그대로 전달해 지속 커넥션을 사용하지 않지만, 똑똑한 프락시는 Proxy-Connection을 Connection으로 변경 해 지속 커넥션을 사용하도록 변경한다.

다만 이 또한 멍청한 프락시 양 옆에 영리한 프락시가 있다면 제대로 동작하지 않는다.

## 4.5.8. HTTP/1.1의 지속 커넥션

HTTP/1.1 부터 keep-alive 대신 개선된 지속 커넥션이 기본적으로 활성화 돼 있다.

## 4.5.9. 지속 커넥션의 제한과 규칙

기본적으로 지속 커넥션이지만 Connection: close를 보내면 커넥션이 끊어진다(클라이언트가 Connection: close 헤더를 포함하면 그 커넥션으로 추가 요청을 보낼 수 없다.).

정확한 Content-Length값을 사용해야 한다.

# 4.6. 파이프라인 커넥션

최초의 요청이 완료되기 전 다음 요청을 보내는 기술로 대기 시간을 없앰으로 네트워크 가동율을 높이고 성능을 향상시킨다. Keep-Alive 이용이 전제로 깔려 있어야한다. 추가로 아래와 같은 제약 사항이 있다.

- 지속 커넥션(여기서는 Keep-Alive)여야 한다
- 응답은 반드시 요청 순서와 같게 와야한다.(다르게 와도 먼저 온 요청이 끝날때 까지 기다려야 한다, Head Of Line 블록킹)
- 커넥션이 끊어져도 완료되지 않은 요청을 다시 보낼 준비가 돼 있어야 한다.
- POST처럼 비멱등성인 요청처럼 반복해서 보낼 경우 문제가 생긴다면 파이프라이닝을 하면 안된다. 어떤 것들이 서버에서 처리 됐는지 클라이언트가 알 방법이 없다.

# 4.7. 커넥션 끊기에 대한 미스터리

커넥션 관리(특히 언제 어떻게 끊는가)에 명확한 기준이 없다.

## 4.7.1. 마음대로 커넥션 끊기

눈치껏 서버가 끊는다.

## 4.7.2. Content-Length와 Truncation

Content-Length 값을 잘 챙기자.

## 4.7.3. 커넥션 끊기의 허용, 재시도, 멱등성

커넥션이 끊길 것을 대비해야 한다. 그러므로 POST 같은 비멱등적인 요청은 파이프라인을 통해 요청하면 안된다.

## 4.7.4. 우아한 커넥션 끊기

# 5. Multiplexed Streams

HTTP/2에서 사용되는 기술로, 기존 HTTP/1.1의 Connection Keep-Alive, Pipelining이 가진 문제점을 개선 했다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/07babc3c-ab9c-4565-a6a0-9d774f266a4c/Untitled.png)

## 5.1. HTTP/2.0 Binary Protocol

기존 HTTP/1.1 대 버전은 메시지 구성이 Plain Text(평문)을 사용하고, 개행으로 구별되었다. HTTP/2.0 부턴 메세지 구성이 바이너리 포멧으로 인코딩 된 Message, Frame으로 돼 있다.

→ HTTP/1.1대 까지 텍스트 기반으로 헤더와 본문이 연결돼 있었다면, HTTP/2.0 부터는 메세지를 Binary 단위로 구성하고 더 작은 프레임으로 쪼개 관리한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3c4821b-d8ef-4b5a-981c-96ad22a8f3fc/Untitled.png)

사진과 같이 HTTP/2.0의 연결은 Binary Framing 통해 나온 이진 데이터를 헤더를 관리하는 HEADERS frame과 DATA frame 으로 나눠 관리 / 전송할수 있게 됐다.

→ 여담으로 이 과정에서 허프만 코딩 압축 방식을 기반으로 하믄 HPACK 압축 방식이 사용되어, 중복되는 헤더와 데이터를 줄 일 수 있도록 했다.

## 5.2. 통신 구조 및 흐름

기존 HTTP/1.1 에서 텍스트 평문으로 요청을 한번에 보냈다면, HTTP/2.0은 평문을 해석 및 압축해 매우 잘게 쪼갠 프레임으로 통신을 한다. 이 프레임으로 이뤄진 메시지들을 스트림 방식을 사용해 양방향으로 데이터를 주고 받는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5251b761-5c49-4076-9e5c-6961dbc45ecc/Untitled.png)

즉 HTTP/2.0에서는 스트림 하나가 다수개의 요청과 응답을 처리하는 구조로 바뀌었다. 이는 한번에 여러개의 메세지를 처리 할수 있다.

응답 프레임들은 요청 순서에 상관 없이 서버에서 만들어진대로 클라이언트에게 전달 될 수 있다.

노션 페이지: https://raehan.notion.site/4-69fbba7ac45341c68cabdf1ff9f7dd88

(참고: [https://web.dev/performance-http2/](https://web.dev/performance-http2/))

