## 4.7.3 커넥션의 끊기의 허용, 재시도, 멱등성

> 한 번 혹은 여러 번 실행됐는지에 상관없이 같은 결과를 반환한다면 그 트랜잭션은 멱등(idempotent)하다고 한다. GET, HEAD, PUT, DELETE, TRACE, OPTIONS 메서드들은 멱등하다고 이해하면 된다.
> 

### 멱등성

- 멱등 (수학): 연산을 여러 번 적용하더라도 결괏값이 달라지지 않는일
    
    → 같은 요청을 반복해도 **항상 동일한 결과를 보장**하는 성질 
    → 해당 요청이 서버의 상태, 데이터 변경하지 않고 단순히 데이터를 읽는 등의 작업에 해당 
    
- HTTP 프로토콜의 핵심 원칙 중 하나
    - 네트워크 통신에서는 요청이 중복될 가능성이 높음
    - 클라이언트가 서버에 같은 요청을 여러번 보낸다면, 서버는 이 요청을 한 번만 처리하고 나머지 요청은 무시해야 함 (중복 요청으로 주문이 중복으로 접수되는 등)

| GET | 멱등 | 단순히 서버로부터 데이터를 읽어오는 요청  |
| --- | --- | --- |
| PUT | 멱등 | 서버의 데이터를 업데이트하는 요청  |
| DELETE | 멱등 | 서버의 데이터가 변경되거나 삭제 |
| POST | 비멱등 | 서버의 상태, 데이터를 변경하는 요청  |
| PATCH | 멱등 | 서버의 상태, 데이터를 일부 변경하는 요청  |

### PUT, DELETE은 왜 멱등이야?

1. `POST`
    1. 서버에 새로운 자원을 생성하거나, **기존 자원을 수정**하는 메소드
    2. 자원의 상태, URI가 변경 가능 
        1. orders 자원에 대해 POST 요청을 보낸다고 가정 
            1. 첫번째 요청
            : orders 자원 새로 생성 → URI /orders/1
            2. 두번째 요청 
            : orders 자원 수정 요청 → URI/orders/2 가능
            → 더 이상 /orders/1 로 접근 불가 
    
    ```json
    //요청
    **POST /orders** HTTP/1.1
    Host: example.com
    Content-Type: application/json
    
    {
        "product": "banana",
        "quantity": 20,
        "price": 1.5
    }
    
    //응답
    HTTP/1.1 **201 Created**
    **Location: /orders/2**
    Content-Type: application/json
    
    {
        "id": 2,
        "product": "banana",
        "quantity": 20,
        "price": 1.5,
        "status": "created"
    }
    ```
    
2. `PUT`
    1. 서버에 존재하는 자원을 완전히 대체 
        1. orders 자원에 대해 PUT 요청을 보낸다고 가정 
            1. orders/1 자원이 완전히 대체됨 
            2. 두번째 요청에도 항상 같은 자원을 대체함 
    
    ```json
    //요청
    **PUT /orders/1** HTTP/1.1
    Host: example.com
    Content-Type: application/json
    
    **{
        "id": 1,
        "product": "apple",
        "quantity": 10,
        "price": 2.0
    } //전체 자원** 
    
    //응답
    HTTP/1.1 **200 OK**
    Content-Type: application/json
    
    **{
        "id": 1,
        "product": "apple",
        "quantity": 10,
        "price": 2.0,
        "status": "updated"
    }**
    ```
    
3. `DELETE`
    1. 서버에 존재하는 자원을 삭제
        1. orders/1 자원에 대해 DELETE 요청을 보낸다고 가정 
            1. orders/1 자원 삭제
            2. 삭제된 자원은 서버에서 더 이상 접근 불가 
            3. 두번째 요청에도 이미 삭제된 자원이 없으므로 결과 유지 

```json
//요청
**DELETE /orders/1** HTTP/1.1
Host: example.com

//응답
HTTP/1.1 **204 No Content**
```

1. `PATCH`
    1. 서버에 존재하는 자원의 일부분만 수정
        1. orders/1 자원에 대해  요청을 보낸다고 가정 
            1. orders/1 만 수정함 (자원 전체 수정 X)
    
    ```json
    //요청
    **PATCH /orders/1** HTTP/1.1
    Host: example.com
    Content-Type: application/json
    
    **{
        "quantity": 5,
        "price": 1.5
    }**
    
    //응답
    **PATCH /orders/1** HTTP/1.1
    Host: example.com
    Content-Type: application/json
    
    {
        "quantity": 5,
        "price": 1.5
    } 
    ```
    

### POST, PUT은 각각 언제 유용할까?

- 둘 다 자원을 생성, 수정하는 데 사용 가능
1. **`POST`**
    1. 서버에 **아직 존재하지 않는 자원**을 생성할 때 
    2. 새로운 피드, 주문 추가 등 
2. `**PUT**`
    1. 서버에 **이미 존재하는 자원**을 업데이트할 때 
    2. 글을 수정, 생성된 주문의 상태를 변경하는 등 
    

### PUT, PATCH는 각각 언제 유용할까?

- 둘 다 자원을 수정하는 데 사용
1. `**PUT**`
    1. **기존 자원을 완전히 대체할 때** 
    2. 요청 본문에 변경할 자원의 전체정보를 포함 
    3. 게시글 전체 내용을 수정, 상품의 모든 정보가 변경되는 경우 
2. `**PATCH**`
    1. **특정 필드만 업데이트, 추가**할 경우 
    2. 요청 본문에 변경된 필드만을 포함 
    3. 게시글 제목만 수정, 상품의 가격만 수정하는 경우 
    

---

## 4장 커넥션 관리

### TCP/IP = 신뢰가는 전송

- **인터넷**에서 **데이터**를 주고받을 때 사용하는 프로토콜

### TCP = 신뢰 담당

- 목적: 데이터의 신뢰성, 안정성을 보장하기 위해
- 데이터 전송 과정에서 오류 발생(패킷 손실 등) 시 **해당 패킷을 재전송(복구)**하도록 함 
→ 전송 과정 중 데이터 유실 최소화, 안정적 데이터 전송

### IP = 전송 담당

- 목적: **인터넷상 데이터를 전송**하기 위해
- 패킷이라는 단위로 데이터를 전송
- 패킷은 각각 출발지, 목적지 주소를 가지고 있음
    - 출발 및 목적지의 IP 주소, 출발 및 목적지의 포트 번호, 데이터 등
- 패킷이 노드들을 거쳐 목적지로 전송되는 방식

---

## HTTP의 Stateless Protocol

- **상태를 가지지 않는 프로토콜**
- HTTP 프로토콜 자체에서 **커넥션 상태를 유지하지 않음**
- **각 [요청과 응답]이 서로 독립적으로 처리** 
→ 이전 요청과 다음 요청이 서로 영향을 주지 않음 
⇒ 이전 요청, 응답에 대한 정보를 저장, 유지하지 않음
    - 인증 같은 기능을 처리하기에는 (매번 인증을 해야 하므로) 한계가 있음 
    → 웹 어플리케이션에서는 상태를 유지하기 위한 쿠키를 사용/

### 지속 커넥션

- 커넥션 상태를 **일정 시간동안 유지 가능**
    - 요청 사이에 연관성을 유지할 수 있음
- 클라이언트~ 서버: 한번의 TCP 커넥션을 열고, 재사용 
→ 여러 개의 요청, 응답을 주고 받음
- **일정 시간동안 클라이언트의 세션, 쿠키 정보 등을 서버에서 보존 가**능
    - 지속 커넥션도 결국은 일정시간이 지나면 끊어짐!
    = 커넥션 상태가 사라짐!
    - 결국 쿠키, 세션 기술이 필요함

<aside>
💡 **지속 커넥션(HTTP 1.1)** 은 얼마간 지속될까?

- 지속 시간이 정해져 있지 않음
-  서버마다 일반적으로 몇 초~ 몇 분 등 다양하게 설정 가능
-  해당 시간이 지나면 Keep-Alive Timeout

</aside>

### HTTP/2

- 다중화 기술 사용 
: **단일 TCP 커넥션**을 사용 → 여러 개의 요청, 응답을 동시에 처리
- 커넥션을 매번 새로 열고 닫을 필요가 없어짐
- 클라이언트~서버 간 상태를 전달하는 쿠키 대신→ 헤더 압축(header compression) 기술을 사용

<aside>
💡 **헤더 압축 기술?**

- HTTP 헤더는 중복된 정보를 포함하고 있어, 데이터 전송량을 증가시킴
→ 미리 정의된 헤더 테이블에 헤더 정보를 추가 
→ 중복된 정보는 한 번만 전송하고, 이후 **인덱스 번호로 대체하여 전송**
→ 전송 데이터 양을 줄임

</aside>

```json
//응답 (헤더 필드, 데이터 등을 **바이너리 형식으로** 모두 압축) 
:status: 200
cache-control: max-age=604800
content-type: text/html; charset=UTF-8
date: Thu, 29 Apr 2021 11:54:44 GMT
expires: Thu, 06 May 2021 11:54:44 GMT
last-modified: Thu, 17 Oct 2019 07:18:26 GMT
server: ECS (nyb/1D14)
vary: Accept-Encoding
// 해당 응답 바디가 gzip 방식으로 압축되어 있다는 것을 나타냄 
**content-encoding: gzip**
content-length: 648
```