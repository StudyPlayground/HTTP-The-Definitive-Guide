## HTTP 메서드의 속성

- 안전(safe)
- 멱등(Idempotent)
- 캐시 가능(Cacheable)
    

## 안정성(Safe)

- 보안 취약성이 아니라, 호출해도 리소스가 변경되지 않는 성질
- GET은 데이터를 조회만 하므로 리소스를 변경, 수정하지 않는다. 즉 안전한 HTTP 메서드다
- 반면 아래 4가지 메서드는 데이터를 변경하거나 삭제하므로 안전하지 않다.

<aside>
💡 **안전과 멱등

- 한 번을 호출하든, 여러번 호출하든 수정이 발생하지 않는 속성은 ?

- 리소스에 수정이 발생한다고 하더라도, 메서드를 여러 번 실행한 결과가 한 번 실행한 결과가 같다면 만족하는 속성은?**

</aside>

## 멱등성(Idempotent)

- 동일한 요청을 한번 보내는 것 = 여러번 연속으로 보내는 것
- 효과도 동일하고, 서버의 상태도 동일함
- 응답 상태 코드가 아니라 서버의 상태임을 유의하자!
    - HTTP 스펙 명시에 의하면, GET, PUT, DELETE는 멱등성을 가지도록, **POST는 PATCH는 멱등성을 가지지 않도록 구현해야 한다**
    

### POST

- 멱등하지 않게 설계된 메서드들은 똑같은 요청을 다시 전송할 경우 문제가 발생함 
(서버 자체나 인터넷 선 등에서 문제 발생 가능)
- 서버에서 정상 처리했음에도, 네트워크 문제로 정상적인 응답을 받지 않았다면, POST 재요청!

### PATCH 멱등 O or X

- PUT이 리소스 전체 교체라면, PATCH는 리소스 부분 수정
- 구현이 PUT과 동일한 방식이라면 멱등성을 가짐
    - 수정할 리소스의 **일부분만 담아서 보내는 경우**
    
    ```jsx
    // 기존의 리소스
    {
      id: 1,
      name: "김철수",
      age: 15  
    }
    ```

        ```jsx
    // 요청 바디
    {
      age: 20
    }
    ```
    

    ```jsx
    // 변경된 리소스
    {
      id: 1,
      name: "김철수",
      age: 20
    }
    ```
    
    - 스펙상 구현 방법에 제한이 없으므로, 데이터를 대체하도록 구성할 필요가 없음
    ⇒ PATCH의 동작을 **`증가`**를 통한 변경
    ⇒ 매 요청마다 age가 1씩 증가하도록 요청한다면, 매 요청마다 서버 상태가 달라짐 -> 리소스
        
       
    
    ## 비멱등한 HTTP 메서드 중복 요청을 방지하는 법
    
    
    1. **클라이언트, 서버 각각에서 중복 요청을 방지하기!**
    : 클라이언트에서 요청을 보낸 후 서버에서 처리되기 전에 네트워크 문제로 인해 요청이 중복으로 전달 →  클라이언트에서는 중복 요청을 방지하더라도, 서버에서는 중복 요청을 처리 → 멱등성을 보장하려면, 서버에서도 중복 요청을 무시하고 이전에 처리한 요청과 동일한 응답을 반환해야 함
    
     * 클라이언트
            - 요청 전송 전에 **이전 요청과 비교하여 같은 요청이 아니면** 요청 전송
            - 요청 전송 후에 서버에서 **응답 받을 때까지 중복 요청 방지 플래그 활성화**하여 다른 요청을 차단
            - 서버에서 응답 받은 후 중복 요청 방지 플래그 비활성화
        
        ```jsx
        let requestPending = false; // 중복 요청 방지 플래그 초기값
        
        function sendRequest() {
          if (!requestPending) {
            requestPending = true; // 중복 요청 방지 플래그 활성화
            // 요청 전송 코드
            // ...
          } else {
            console.log("이전 요청이 아직 처리 중입니다.");
          }
        }
        
        function handleResponse() {
          // 응답 처리 코드
          // ...
          requestPending = false; // 중복 요청 방지 플래그 비활성화
        }
        ```
        
    * 서버
            - 요청 처리 중에 중복 요청 방지 플래그를 사용하여 같은 요청이 여러 번 들어오면 처리하지 않도록 함
            - 요청 처리 결과를 캐시하여 같은 요청이 여러 번 들어와도 캐시된 결과를 바로 반환함으로써 처리 속도를 높임
            - 응답 전송 후에 클라이언트에서 요청 중복 방지 플래그를 확인하여 중복 요청을 막음
    
    2. **ID와 UUID**
        - 일반적인 ID는 UUID를 사용하는 것보다 중복 요청 방지에 취약
            - 일반적인 ID는 시간이 지나면서 중복될 가능성이 있기 때문
        - 클라이언트가 UUID를 사용해서 중복 요청 → 서버에서는 중복 요청을 하지 않는다면 ?
            - 중복 요청이 발생하더라도 각 요청마다 UUID가 생성되므로, 서버에서는 각각의 요청을 고유한 요청으로 인식하고 처리
        
        <aside>
        💡 일반적으로 중복 요청에 대한 방지를 위한 ID는 서버에서 생성하여 응답으로 반환한다. 클라이언트가 새로운 데이터를 POST 할 때, 요청 본문에 ID 값을 포함시키지 않아도 된다. 서버에서 새로운 데이터를 생성하면서, 자체적으로 ID 값을 생성하여 응답으로 전달하기 때문
        
        </aside>
        
        ```jsx
        import uuid
        
        def create_new_data():
            new_data = {
                'id': str(uuid.uuid4()), # 새로운 ID 값 생성
                'name': 'John Doe',
                'age': 30
            }
            # 데이터 생성 및 응답
            return new_data
        ```
        
        **POST 요청 본문:**
        
        ```jsx
        {
            "name": "John Doe",
            "age": 30
        }
        ```
        
        **POST 응답 본문:**
        
        ```jsx
        {
            "id": "6c84fb90-12c4-11e1-840d-7b25c5ee775a",
            "name": "John Doe",
            "age": 30
        }
        ```
        
    
    <aside>
    💡 **클라이언트가 ID를 생성하는 것이 유용한 경우**는?
    
    - 오프라인 상태에서 새로운 데이터를 생성하고, 서버와 연결되었을 때 해당 데이터를 전송하는 경우
    → 클라이언트에서 임시적인 id를 생성하여, 서버와 동기화된 후 서버에서 새로운 id를 할당받아서 해당 값을 업데이트
    
    </aside>
    
    ```jsx
    const data = {
      id: generateTempId(), // 임시적인 id 생성
      title: "New Post",
      content: "This is a new post"
    };
    
    fetch("/posts", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data)
    })
      .then(response => response.json())
      .then(newData => {
        // 서버에서 새로운 id를 할당받아 임시적인 id를 업데이트
        updateData(data.id, newData.id, newData);
      })
      .catch(error => {
        console.error(error);
      });
    ```
    
    ## 캐시 가능성
    
    : 응답 결과 리소스를 캐싱해서 효율적으로 사용할 수 있는가

    - 스펙상으로 GET, POST, PATCH 캐시 가능
    - 실제로는 **GET이나 HEAD 정도만 캐시로 이용이 가능**하고 POST 와 PATCH 는 지원되지 않는 경우가 일반적
        - 캐시를 이용하려면 원 데이터가 변경되지 않고 유지되어야 하는데, GET을 제외한 메서드는 기본적으로 데이터 변경이 일어나는 메서드 이므로, 호출로 인해 데이터가 변경되면 캐시 데이터와 불일치 됨
        - 유지가 어렵고 구현도 복잡하여 캐시를 이용하지 않음!
    
    ### reference
    
    [🌐 HTTP의 멱등성 · 안정성 · 캐시성 💯 완벽 이해하기](https://inpa.tistory.com/entry/WEB-🌐-HTTP의-멱등성-·-안정성-·-캐시성-💯-완벽-이해하기)